Linux文件

1）三个重要的设备文件
/dev/console				// 系统控制台，错误及诊断信息总是发送到此设备
/dev/tty						// 一个进程的控制终端（键盘、显示器或窗口）
/dev/null						// null设备，任何写入到此设备的信息将丢失，不需要的东西可重定向于此
注：
cp /dev/null file  	// 创建空文件
touch file         	// 如果文件不存，创建空文件，否则改变文件的时间戳（timestamps）

2）系统调用与设备驱动（System Calls and Device Drivers）
系统内核由一系列设备驱动组成．设备驱动封装了所用硬件独立的特征．可通过系统调用访问设备驱动：
open: 	打开文件或设备（Open a file or device）
read: 	从文件或设备读（Read from an open file or device）
write: 	写入文件或设备（Write to a file or device）
close: 	关闭文件或设备（Close the file or device）
ioctl: 	传递控制信息到设备驱动（Pass control information to a device driver）
通过系统调用访问文件或设备并非很有效（一般情况下我们使用库函数）

3）低级别文件访问（Low-Level File Access）
文件描述符（file descriptors：实际是一个整数）与进程相关联．每个进程起动时，总有３个文件描述符是打开的：
0: 标准输入（Standard input）
1: 标准输出（Standard output）
2: 标准错误（Standard error）

size_t write(int fildes, const void *buf, size_t nbytes); // 写：返回写入的字节数
size_t read(int fildes, void *buf, size_t nbytes);				// 读：返回读取的字节数
int open(const char *path, int oflags);										// 打开：返回文件描述符
int open(const char *path, int oflags, mode_t mode);			// 打开：如果oflags使用O_CREAT，则需使用mode
int close(int fildes);																		// 关闭
int ioctl(int fildes, int cmd, ...);											// IO控制

oflags: 指定打开标志：必选标识 | 可选标识 | 可选标识
必选标识：O_RDONLY（只读），O_WRONLY（只写），O_RDWR（读写）
可选标识： O_APPEND（添加），O_TRUNC（长度为0），O_CREAT（创建），O_EXCL（配合O_CREAT，打开为原子操作）

注：调用open时，使用标识O_CREAT | O_EXCL ，可创建Lock文件（参见Beginning Linux Programming(3rd Edition)第7章）

mode：当oflags使用O_CREAT时，指定文件初始权限（Initial Permissions）
S_IRUSR，	S_IWUSR, 	S_IXUSR,    // 指定用户读、写、执行权限
S_IRGRP, 	S_IWGRP, 	S_IXGRP,    // 指定组用户读、写、执行权限		
S_IROTH,	S_IWOTH,	S_IXOTH,	// 指定其它用户读、写、执行权限

注：文件的权限受以下两方面影响：
a. 文件权限仅在创建时指定
b. 用户mask（通过umask命令设置）影响创建文件的权限
umask是一个系统变量用3个八进制数组成（例如032表示创建的文件不具有S_IWGRP, S_IXGRP, S_IWOTH权限）


4）其它管理文件的系统调用（Other System Calls for Managing Files）
a. lseek系统调用
off_t lseek(int fildes, off_t offset, int whence);  // 移动文件指针到指定位置

b. fstat, stat, 和lstat系统调用
返回文件状态信息（文件权限、类型、用户ID，组ID，访问时间等），stat是一结构体，sys/stat.h定义
int fstat(int fildes, struct stat *buf);	        // 返回文件的状态信息
int stat(const char *path, struct stat *buf);		// 如果是符号文件，返回符号文件引用的文件状态信息
int lstat(const char *path, struct stat *buf); 	    // 如果是符号文件，返回符号文件本身的状态信息

c. dup, dup2系统调用（复制文件描述符）
int dup(int fildes);				    // 复制文件描述符， 返回一个新的描述符指向同一文件
int dup2(int fildes, int fildes2);      // 指定一个描述符fildes2用于复制（fildes2原指向的文件会关闭） 返回值  >= fildes2
注：dup总是分配最小的可用描述符作为新的描述符（当然，新旧文件描述符是指向同一个文件的）

下面例子有助于理解dup与dup2
fildes = open("file",..); 
old_stdout = dup(1);      		        // 复制标准输出设备的描述符1，描述符old_stdout现在也指向标准输出设备
dup2(fildes, 1);				        // 描述符1现指向了file
write(1, msg, strlen(msg));		        // 向描述符1指向的文件写数据（相当于写文件file）
dup2(old_stdout, 1):					// 描述符1现在又指向了标准输出设备


5）标准I/O库（The Standard I/O Library）
fopen, fclose，fread, fwrite，fflush，fseek               // 文件打开、关闭、读、写、刷新、移动
fgetc, getc, getchar，fputc, putc, putchar，fgets, gets   // 字符/字符串输入/输出
printf, fprintf, and sprintf，scanf, fscanf, and sscanf   // 格式化输入/输入

许多标准库函数的错误值，通过全局变量errno设置
#include <errno.h>
extern int errno;
int ferror(FILE *stream);       	    // 测试文件错误指示符（error indicator）是否设置
int feof(FILE *stream);				    // 测试文件结束指示符（end-of-file indicator）是否设置	
void clearerr(FILE *stream);	        // 清除文件错误及结束指示符

int fileno(FILE *stream);					    // 由文件流得到文件描述符
FILE *fdopen(int fildes, const char *mode);		// 打开文件描述符

6）文件和目录维护（File and Directory Maintenance）
以下均为系统调用
int chmod(const char *path, mode_t mode); 	            // 改变文件权限（mode参数与系统调用open使用相同）
int chown(const char *path, uid_t owner, gid_t group); 	// 改变文件拥有者
int unlink(const char *path);					        // 移除链接（引用计数为0时，会删除文件，创建临时文件可用此技巧）
int link(const char *path1, const char *path2);	        // 创建链接（path2指定链接路径）
int symlink(const char *path1, const char *path2);      // 创建符号链接
int mkdir(const char *path, mode_t mode);		        // 创建目录（mode与系统调用open在使用O_CREAT时相同）
int rmdir(const char *path);						    // 只能删除一个空目录
int chdir(const char *path);					        // 转向其它目录
char *getcwd(char *buf, size_t size);				    // 获取当前目录（进程所在目录删除或权限改变时返回NULL）

7）目录搜索（Scanning Directories）
#include <sys/types.h>
#include <dirent.h>

dirent结果包含：
ino_t d_ino:   文件结点（The inode of the file）
char d_name[]: 文件名（The name of the file）
进一步的信息可通过stat系统调用获得

DIR *opendir(const char *name);	            // 打开目录流
int closedir(DIR *dirp);                    // 关闭目录流
struct dirent *readdir(DIR *dirp);          // 返回dirp目录中指向下一个目录项的指针
long int telldir(DIR *dirp);			    // 记录当前目录流位置
void seekdir(DIR *dirp, long int loc);	    // 重新设置到目录流中的位置

// 打印目录（depth控制输出）
void printdir(char *dir, int depth) {
	DIR *dp;
	struct dirent *entry;
	struct stat  statbuf;
	if((dp = opendir(dir)) == NULL) {       // 打开目录
		fprintf(stderr,”cannot open directory: %s\n”, dir);
		return;
	}
	chdir(dir);     		                // 进入子目录
	while((entry = readdir(dp)) != NULL) {
		lstat(entry->d_name,&statbuf);      // 获取文件状态信息
		if(S_ISDIR(statbuf.st_mode)) {
			if(strcmp(“.”,entry->d_name) == 0 || strcmp(“..”,entry->d_name) == 0)
				continue;	
			printf(“%*s%s/\n”,depth,””,entry->d_name);      // 打印目录
			printdir(entry->d_name,depth+4);    			// 递归子目录
		} else {
			printf(“%*s%s\n”,depth,””,entry->d_name);		// 打印文件
		}
	}
	chdir(“..”);  			                // 回到父目录
	closedir(dp); 			                // 关闭目录
}

8）错误（Errors）
前面已提到，许多系统或函数调用失败时，会设置errno的值
头errno.h中定义了常见错误
EPERM: 		Operation not permitted
ENOENT: 	No such file or directory
EINTR: 		Interrupted system call
EIO: 	    I/O Error
EBUSY: 		Device or resource busy
EEXIST: 	File exists
EINVAL: 	Invalid argument
EMFILE: 	Too many open files
ENODEV: 	No such device
EISDIR: 	Is a directory
ENOTDIR: 	Isn’t a directory

char *strerror(int errnum);     // 将错误号映射成描述错误的字符串
void perror(const char *s);     // 将当前错误号映射成字符串并加上指定的前缀后输出到标准错误流


9）/proc文件系统（The /proc File System）
代表驱动或内核信息（此目录下的数字（目录）表示运行的进程ID）
cat /proc/cpuinfo  	 		    // 查看CPU信息
cat /proc/meminfo		 		// 查看内存信息
cat /proc/version				// 查看版本号
cat /proc/net/sockstat	        // 查看Socketw信息

10）高级主题：fcntl和mmap（Advanced Topics: fcntl and mmap）
a. fcntl系统调用：操作文件描述符
int fcntl(int fildes, int cmd);
int fcntl(int fildes, int cmd, long arg);

fcntl(fildes, F_DUPFD, newfd);  // 复制文件描述符（返回的描述符大于等于newfd）
fcntl(fildes, F_GETFD):	        // 判断文件描述符是否已关闭（在exec系列系统调用之后）
fcntl(fildes, F_SETFD, flags):  // 设置文件描述符标志（一般总是FD_CLOEXEC）

锁住文件的某些部分（Locking Regions）的命令cmd为：
F_GETLK			// 获取锁信息(并不拥有锁)，传递相要请求的锁的信息，fcntl返回-1表失败（并重写传递的结构体，不则不改变）
F_SETLK			// 获取锁，fcntl返回-1表失败
F_SETLKW		// 与F_SETLK一样，除了等待直到获取到相应的锁
此时参数arg为指向结构体的指针：struct flock *flock_structure
flock的成员有：
short l_type			锁类型：F_RDLCK（读锁）、F_WDLCK（写锁）、F_UNLCK（取消锁）
short l_whence		    SEEK_SET（文件开始处）, SEEK_CUR, SEEK_END
off_t l_start			相对于l_whence的偏移
off_t l_len				长度
pid_t l_pid				进程ID

b. mmap系统调用（内存映射，2.0版本后支持）
// 创建内存映射
// addr:   内存地址（设为0由系统决定）
// len:    映射长度
// prot:   指定内存片断访问权限：PROT_READ（可读），PROT_WRITE（可写），PROT_EXEC（可执行），PROT_NONE（不可访问）
// flag:   指定片断变化的影响：MAP_PRIVATE（片断改变是私有的、局部的），MAP_SHARED（片断变化引起文件变化）
//         MAP_FIXED（片断必须是addr指定的地址）
// fildes: 映射的文件描述符
// off:	   文件数据偏移
void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off);

// 使得所用内存片断的变化同步到映射的文件
int msync(void *addr, size_t len, int flags);

// 取消内存映射
int munmap(void *addr, size_t len);

// 以下程序展示了mmap的用法
#include <unistd.h>
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <stdlib.h>
typedef struct {
	int integer;
	char string[24];
} RECORD;

#define NRECORDS (100)

int main()
{
	RECORD record, *mapped;
	int i, f;
	FILE *fp;
	
	fp = fopen(“records.dat”,”w+”);  
	for(i=0; i<NRECORDS; i++) {
		record.integer = i;
		sprintf(record.string,”RECORD-%d”,i);
		fwrite(&record,sizeof(record),1,fp);
	}
	fclose(fp);
	
	f = open(“records.dat”,O_RDWR);
	mapped = (RECORD *)mmap(0, NRECORDS*sizeof(record),
													PROT_READ|PROT_WRITE, MAP_SHARED, f, 0);
	mapped[43].integer = 243;
	sprintf(mapped[43].string,”RECORD-%d”,mapped[43].integer);
	msync((void *)mapped, NRECORDS*sizeof(record), MS_ASYNC);
	munmap((void *)mapped, NRECORDS*sizeof(record));
	close(f);
	exit(0);
}
