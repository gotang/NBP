POSIX 线程

1. 线程创建

使用多线程库时，应定义宏_REENTRANT（可重入）提示编译器，编译器可能会做以下工作：
a. 某些函数名可能加_r后辍，例如：gethostbyname变成gethostbyname_r
b. 某些stdio.h中的函数可能用宏带代替（使其可重入）
c. errno.h中的errno变量被改变一个函数调用

所需头文件：#include <pthread.h> 
所需链接项：-lpthread

// 创建线程
int pthread_create( pthread_t *thread,              // 返回创建线程ID
                    pthread_attr_t *attr,           // 线程属性(默认joinable)
                    void *(*start_routine)(void *), // 执行函数指针
                    void *arg );                    // 函数参数
                    
// 退出当前线程, retval不应指向线程局部变量
void pthread_exit(void *retval);

// 等待线程，线程的返回值由*thread_return指向
int pthread_join(pthread_t thread, void **thread_return);

// 使线程detached, 这样其终止时资源将自动回收，而无须join线程
int pthread_detach(pthread_t thread);

2. 线程同步

1）使用信号量同步（Synchronization with Semaphores）
包含头文件：#include <semaphore.h>

// 初始化信号量
// pshared:  1 - 进程间共享受， 0 - 仅在进程内使用
// value: 初始值
int sem_init(sem_t *sem, int pshared, unsigned int value);

// 释放信号量资源（如果某线程正等待此信号量，则会引起错误）
int sem_destroy(sem_t * sem);

// 等待直到信号为正，并将信号量减1
int sem_wait(sem_t * sem);

// 信号量加1，换醒正在等待的其它线程
int sem_post(sem_t * sem);


2）使用互斥体同步（Synchronization with Semaphores）

// 初始化互斥体
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t* mutexattr);

// 释放互斥体资源
int pthread_mutex_destroy(pthread_mutex_t *mutex);

// 锁住互斥体（进入临界区）
int pthread_mutex_lock(pthread_mutex_t *mutex));

// 解锁互斥体（退出临界区）
int pthread_mutex_unlock(pthread_mutex_t *mutex);

3) 使用条件变量同步
// 初始化条件变量
int pthread_cond_init(pthread_cond_t *cond,　const pthread_condattr_t *attr);

// 释放条件变量
int pthread_cond_destroy(pthread_cond_t *cond);

// 通知条件满足（broadcast通知所有，signal通知一个等待进程）
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);

// 等待条件满足(timedwait版本指定超时)
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int pthread_cond_timedwait(pthread_cond_t *cond,　
    pthread_mutex_t * mutex,　const struct timespec *abstime);


3. 线程属性（Thread Attributes）

// 初始化/释放线程属性对象
int pthread_attr_init(pthread_attr_t *attr);     
int pthread_attr_destroy(pthread_attr_t *attr);

// 设置/获取可分离状态
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);

// 设置/获取调度策略
int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);
int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy);

// 设置/获取调度参数
int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);
int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);

// 设置/获取调度继承
int pthread_attr_setinheritsched(pthread_attr_t *attr, int inherit);
int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *inherit);

// 设置/获取调度范围
int pthread_attr_setscope(pthread_attr_t *attr, int scope);
int pthread_attr_getscope(const pthread_attr_t *attr, int *scope);

// 设置/获取线程栈大小
int pthread_attr_setstacksize(pthread_attr_t *attr, int scope);
int pthread_attr_getstacksize(const pthread_attr_t *attr, int *scope);

各参数含义：
detachedstate: 分离状态
PTHREAD_CREATE_JOINABLE  	加入状态，可调用pthread_join等待（默认状态）
PTHREAD_CREATE_DETACHED		分离状态，不能调用pthread_join等待

schedpolicy: 	调度策略
SCHED_OTHER	 	缺省调度策略
SCHED_RP		循环调度（round-robin scheduling）
SCHED_FIFO		先进先出调度（FIFO）

schedparam:		调度参数，配合SCHED_OTHER使用（其仅有的成员sched_priority指定优先级）

inheritsched:	调度继承
PTHREAD_EXPLICIT_SCHED		    显示指定调度策略（缺省）
PTHREAD_INHERIT_SCHED			继承父线程的调度策略

scope: 调度范围
PTHREAD_SCOPE_SYSTEM 目前只支持系统范围内调度

stacksize: 栈大小

4. 取消一个线程（Canceling a Thread）

// 请求线程发送终止
int pthread_cancel(pthread_t thread);

// 线程自己可设置取消状态
// state: PTHREAD_CANCEL_ENABLE（缺省开启取消状态），PTHREAD_CANCEL_DISABLE（不启用，忽略终止信号）
// oldstate：保存线程的原来状态
int pthread_setcancelstate(int state, int *oldstate);

// 设置取消类型, type值：
// PTHREAD_CANCEL_ASYNCHRONOUS （异步方式）引起取消立即执行
// PTHREAD_CANCEL_DEFERRED     （缺省方式）等待直到调用了pthread_join, pthread_cond_wait，
// pthread_cond_timedwait, pthread_testcancel, sem_wait, or sigwait之一
int pthread_setcanceltype(int type, int *oldtype);

// Push和Pop线程清理过程（cancellation clean-up handler）（也就是一函数指针啦）
// 以下情况会导致清理过程弹出并执行
// 1 线程被cancel时，所有清理过程弹出并执行
// 2 调用pthread_exit()时, 所有清理过程弹出并执行（执行return语句不会）
// 3 调用pthread_cleanup_pop()传入exectue非零时，stack顶部的清理过程弹出并执行
// POSIX.1标准允许pthread_cleanup_push和pthread_cleanup_pop作为宏实现，展开后可能分别包含{和}，
// 因此这两个函数之间的变量是局部的（应该避免），如果其间有return, break, continue, 或goto
// 则结果未定义
void pthread_cleanup_push(void (*routine)(void *), void *arg);
void pthread_cleanup_pop(int execute);

注：多线程时fork()可能出现问题
1) fork()函数创建的子进程通过copy父进程的(所有的内存页，打开的文件描述符等)而生成, 但子进程中仅有一个线程。
也就是说fork()仅clone了调用它的那个线程，其它线程并没有被clone. 如果父进程中的各线程中使用了同步机制(
critical sections, mutexes等), 则可能出现死锁等问题

2) 由于fork时打开的文件描述符也会copy, 可设置FD_CLOEXEC标识，当子进程创建时, 将自动close相应的文件描述符：
fd = open ("file", O_RDWR | O_CREAT | O_TRUNC, 0600);
fcntl(fd, F_SETFD, FD_CLOEXEC);
但open和fcntl之间fork时则会出现问题，因此新的linux内核(2.6.23后)增加了open中增加了O_CLOEXEC标识来保证
文件描述符自动关闭.

3) 一般来说，可在调用fork()后调用exec*函数来替换一个进程没有问题. 此外还有一函数可提供handler来处理
int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));
其中：
prepare - 在新进程产生之前调用（Called just before a new process is created.）
parent  - 新进程在父亲中创建之后调用（Called after a new process is created in the parent.）
child   - 新进程在子进程创建之后调用（Called after a new process is created in the child.）



