Linux基础知识

1.Linux将所有设备看成文件。
设备文件分为两种：字符设备文件（c）、块设备文件（b） 
设备文件一般存放在/dev目录下
/dev/hd[a-t]：	IDE设备
/dev/sd[a-z]：	SCSI设备
/dev/fd[0-7]：	标准软驱
/dev/md[0-31]：	软raid设备
/dev/loop[0-7]：本地回环设备
/dev/ram[0-15]：内存
/dev/null：		无限数据接收设备 ,相当于回收站
/dev/zero：		无限零资源
/dev/tty[0-63]：虚拟终端
/dev/ttyS[0-3]：串口
/dev/lp[0-3]：	并口
/dev/console：	控制台
/dev/fb[0-31]：	framebuffer
/dev/cdrom => 	/dev/hdc
/dev/modem => 	/dev/ttyS[0-9]
/dev/pilot => 	/dev/ttyS[0-9]


2.区分/dev/tty、/dev/console、/dev/pts、/dev/ttyn
通常我们在linux下看到的控制台(console)是由几个设备完成的。分别是/dev/ttyN（其中tty0就是/dev/console、
tty1，tty2就是不同的虚拟终端（virtual console））.通常使用热键ctrl + alt + Fn来在这些虚拟终端之间进行切换。
所有的这些tty设备都是由linux/drivers/char/console.c和vt.c对应。

/dev/pts是远程登陆(telnet,ssh等)后创建的控制台设备文件所在的目录。由于可能有好几千个用户登陆，
所以/dev/pts其实是动态生成的，不象其他设备文件是构建系统时就已经产生的硬盘节点(如果未使用devfs) 

第一个用户登陆，console的设备文件为/dev/pts/0，第二个为/dev/pts/1，以此类推。
这里的0、1、2、3不是具体的标准输入或输出，而是整个控制台。
你可尝试 echo "aaaaaa" > /dev/pts0、1、2……。

/dev/tty			指的是当前所处的终端,输出到此的内容只会显示在当前工作的终端显示器上
/dev/console	就是tty0 
/dev/pts			是远程登陆(telnet,ssh等)后创建的控制台设备文件所在的目录


3.设备模块
1）insmod（插入模块到内核）
insmod /lib/modules/examples/hello1.ko                  // 须指定模块的绝对路径
insmod /lib/modules/examples/hello1.ko debug_enable=1		// 可指定模块参数
 
2）lsmod（列出内核中已加载的模块）
$ lsmod
Module      Size  	Used by
ext3        121096  0
jbd         49656  	1 ext3
...
$
注：Used by指出了模块的依赖性（如exit依赖于jbd）

3） rmmod（删除模块）
rmmod ext3					// 与删除模块ext3，但不会考虑模块间依赖性

4）modprobe（加载或删除模块，自动处理模块的依赖性）
modprobe ext3				// 加载ext3.ko到内核，并自动加载其依赖的jdb.ko
modprobe -r ext3		// 删除ext3.ko的同时也删除jdb.ko

注：modprobe由配置文件modprobe.conf驱动的，modprobe.conf将设备与驱动联系起来
如果不存在modprobe.conf，modprob使用缺省规则（-c选项显示缺省规则）

modprobe.conf文件格式如下：
...
alias eth1 orinoci_pci
options eth1 orinoco_debug=9
alias eth0 e100
alias snd-card-0 snd-intel8x0
options snd-card-0 index=0
...

当内核启动时，发现了eth1设备时，通知驱动modprobe加载orinoci_pci，并传递可选参数orinoco_debug=9
类以地发现设备eth0时，加载驱动e100; 发现

5）depmod（创建模块依赖性）
modprobe如何知道模块间的依赖性? 
当modprobe执行时，（在模块安装的目录下）会搜索一个名叫modules.dep的文件
modules.dep列出了模块间的依赖性（以绝对路径列出），如：
/.../ext3.ko: /.../jbd.ko  	// 指出ext3.ko依赖于jbd.ko，
modules.dep文件是由depmod创建的，一般而言，编译内核时会自动运行depmod

6)modinfo（模块信息）
mod ext3 	// 显示模块ext3的相关信息

7)mknod（创建设备节点）
mknod /dev/hello c 234 0		// 创建设备hello（字符设备，主设备号234，次设备号0）

语法：mknod [OPTION] NAME TYPE [MAJOR MINOR]

NAME：	设备名
MAJOR：	主设备号
MINOR：	次设备号
TYPE：
b      	创建块设备文件（buffered）
c, u   	创建字符设备文件(unbuffered)
p      	创建FIFO

注：
a.创建类型为b,c或u的节点时，必须指定主次设备号，创建类型为p的设备不能指定主次设备号
b.open系统调用时，内核将搜索一个已注册的与主设备号相同的设备驱动
c.次设备号主要是为了实现多个设备共用一个驱动，内核并不使用次设备号，它只是简单地传递驱动处理

4.git的基本使用

git config --global user.name "Your Name Comes Here"
git config --global user.email you@yourdomain.example.com  
git branch                              // 显示所有branch('*' 表示current brach)
git branch xxx                          // 创建一个新的branch xxx
git branch -d xxx                       // 删除branch 
git branch -D xxx                       // 强制删除branch
git status                              // 显示状态   
git chechout xxx                        // 切换branch, xxx可以是branch, 也可以是一个(文件或目录的)path
git add  <path>                         // 添加path　
git rm   <path>                         // 册除path
git commit -m "comments"                // commit代码到本地仓库
git pull                                // 从serve端更新代码
git push                                // commit代码到server
git reset <commit-obj>                  // 返回到上一次commit
git reset --hard <commit-obj>           // 返回到某个commit, --hard强制执行
git reset --mixed <commit-obj>          // 变化保留，但是不标记为commit 
git merge <other-branch>                // merger <other-branch>到current branch

git merge -s recursive  -Xtheirs        // 使用recursive算法merge, 冲突时使用theirs changes
git merge -s recursive  -Xours          // 使用recursive算法merge, 冲突时使用ours changes

git checkout --others   xxx             // 用于解决merge冲突using theirs changes
git checkout --ours     xxx             // 用于解决merge冲突using ours changes

                                        
git clone url [<dir>] [-b <branch>]     // clone分支
git log　[<file-path>]                   // 显示commit log
git log -p -2                           // 显法最近2个commit的内容　
git log --stat                          // 显示change/add/del的文件

git cherry-pick [commit]                // apply单个commit



5.svn常用命令（http://www.jb51.net/os/RedHat/2461.html）

1）将文件checkout到本地目录 
svn checkout path（path是服务器上的目录） 
例如：svn checkout svn://192.168.1.1/pro/domain 
简写：svn co svn://192.168.1.1/pro/domain

2）往版本库中添加新的文件 
svn add file 
例如：svn add test.php(添加test.php) 
svn add *.php(添加当前目录下所有的php文件) 

3）将改动的文件提交到版本库 
svn commit -m “LogMessage“ [-N] [--no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关) 
例如：svn commit -m “add test file for my test“ test.php 
简写：svn ci  -m “add test file for my test“ test.php 

4）加锁/解锁 
svn lock -m “LockMessage“ [--force] PATH 
例如：svn lock -m “lock test file“ test.php 
svn unlock PATH 

5）更新到某个版本 
svn update -r m path 
例如： 
svn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。 
svn update -r 200 test.php(将版本库中的文件test.php还原到版本200) 
svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit) 
简写：svn up 

6）查看文件或者目录状态 
1)svn status path（目录下的文件和子目录的状态，正常状态不显示） 
【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】 
2）svn status -v path(显示文件和子目录状态) 
第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。 
注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。 
简写：svn st 

7）删除文件 
svn delete path -m “delete test fle“ 
例如：svn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file” 
或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，推荐使用这种 
简写：svn (del, remove, rm) 

8）查看日志 
svn log path 
例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化 

9）查看文件详细信息 
svn info path 
例如：svn info test.php 

10）比较差异 
svn diff path(将修改的文件与基础版本比较) 
例如：svn diff test.php 
svn diff -r m:n path(对版本m和版本n比较差异) 
例如：svn diff -r 200:201 test.php 
简写：svn di -r 200:201 test.php <div style="text-align: justify"></div>

11）将两个版本之间的差异合并到当前文件 
svn merge -r m:n path 
例如：svn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下） 

12）SVN 帮助 
svn help 
svn help ci 

—————————————————————————— 
以上是常用命令，下面写几个不经常用的 
—————————————————————————— 
13）版本库下的文件和目录列表 
svn list path 
显示path目录下的所有属于版本库的文件和目录 
简写：svn ls path

14）创建纳入版本控制下的新目录 
svn mkdir: 创建纳入版本控制下的新目录。 
用法: 1、mkdir PATH… 
2、mkdir URL… 
创建版本控制的目录。 
1、每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增 
调度，以待下一次的提交。 
2、每个以URL指定的目录，都会透过立即提交于仓库中创建。 
在这两个情况下，所有的中间目录都必须事先存在。 

15）恢复本地修改 
svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert: 
用法: revert PATH… 
注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复 
被删除的目录 

16）代码库URL变更 
svn switch (sw): 更新工作副本至不同的URL。 
用法: 1、switch URL [PATH] 
2、switch –relocate FROM TO [PATH...] 
1、更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将 
服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的 
方法。 
2、改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动 
(比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用 
这个命令更新工作副本与仓库的对应关系。 

17）解决冲突 
svn resolved: 移除工作副本的目录或文件的“冲突”状态。 
用法: resolved PATH… 
注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的 
相关文件，然后让 PATH 可以再次提交。 
18、输出指定文件或URL的内容。 
svn cat 目标[@版本]…如果指定了版本，将从指定的版本开始查找。 
svn cat -r PREV filename > filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)


