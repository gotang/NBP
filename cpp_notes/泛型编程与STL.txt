泛型编程与STL（中文版，候捷译）
----------------------------------------------------------------------------------------------------


第一篇	泛型编程导入
----------------------------------------------------------------------------------------------------

第1章 STL 巡礼（略）


第2章 算法与区间
2.1 线性查找
查找区间（闭开区间）：[first, last)
2.2 Concepts 和 Modeling
举例：
Input Iterator是一个Concept
char* 是Input Iterator的一个Model

2.3 Iterator（迭代器）
Input Iterator		只读的
Output Iterator		只写的
Forward Iterator	可读写的、单向迭代
Bidirectional Iterator	可读写的、双向迭代
Random Access Iterator	随机读写的

2.4 Refinement(精炼、强化)
举例：
Forward Iterator是Input Iterator, Output Iterator的Refinement
Bidirectional Iterator是Forward Iterator的Refinement


第3章 再论Iterator
3.1 Iterator Traits（迭代器特征）与Associated Types(相关类型)
Iterator中一般包含的类型有：
1）Value Type（数值型别）可通过模板的部分特化来实现
2）Difference Type（差距类型）
举例：两个Iterator P1, P2的差距P2 - P1的类型（不一定是32位的整数，实现技巧与Value Type类似）
3）Referene Type(引用类型)	operator*返回T&
4）Pointer Type(指针类型)	operator->返回T*
5) Category（类别）
这些类型可通过iterator_traits技巧实现。

3.2定义新组件
定义你自己的组件，也就是要提供类似于Iterator的相关特征，以便STL算法能作用于其上。


第4章 Function Object(函数对象)
举例：
判断是否为偶数的一元函数对象：
template<typename Number> struct even {
	bool operator()(Number x) { return (x & 1) == 0 }
}


第5章 Containers(容器)
举例：
一个最平淡无奇的Container
template <class T>
struct trivial_container {
	typedef T 			value_type;
	typedef value_type* 		pointer;
	typedef const value_type* 	const_pointer;
	typedef value_type& 		reference;
	typedef const value_type& 	const_reference;

	typedef value_type*		iterator;
	typedef const value_type*	const_iterator;

	typedef ptrdiff_t		difference_type;
	typedef size_t			size_type;

	const_iterator begin() const {}
	const_iterator end() const {}
	
	size_type size() const { return 0; }
	bool empty() const { return true; }
	size_type max_size() const {return 0;}
	
	void swap(trivial_constainer&) {}
}
它满足Container的所有条件，可用来测试以Container为参数的算法，或以此为参考定制自己的容器。


第二篇 参考手册：STL Concepts
----------------------------------------------------------------------------------------------------

第6章 基本概念

6.1 Assignable要求：Copy constructor 和 operator =

6.2 Default constructible要求：Default constructor

6.3 Equality Comparable要求: operator ==
Identity(同一性): 	&x == &y -> x == y
Reflexivity(自反性)：	x == x
Symmetry(对称性): 	x == y -> y = x
Transitivity(传递性) 	x == y 且 y == z -> x == z
数学上的等价关系须满足后三项

注：正规类型（regular type）同时满足：Assignable, Default constructible, Equality Comparable

6.4 可序性（Ordering）(要求：operator < )
6.4.1 LessThan Comparable要求： 任意x, y之间存在：x < y 或 y < x
偏序（部分有序）partial ordering
6.4.2 Strict weakly Comparable要求：partial ordering 且 stirct weak ordering
Stirct Weak Ordering定义：如果 x < y 和 y < x 皆不为真，则x == y
这便引出了数学上的等价类，一个等价类中的所有元素都等价（但并非相等）
全序是一种特别的stirct weak ordering，简单地说，每个等价类中只有一个元素。

注：大数多算法（如sort）其实是依赖stirct weak ordering。因为LessThan Comparable并未提供足够强烈的保证


第7章 Iterators(迭代器 or 泛型指针)

7.1 Trivial Iterator
强化自：Assignable， Equality Comparable
还要求：可解引用(dereference) 即要求：operator* 和 operator-> 

注：并非所有Iterator 都定义operator->， 例如int* 类型的自然不存在此操作符咯，但t->m == (*t).m是成立的

7.2 Input Iterator
强化自： Trivial Iterator
还要求：前置operator++， 后置operator++(int)， 
typename iterator_traits<T>::value_type,
typename iterator_traits<T>::difference_type,
typename iterator_traits<T>::reference_type,
typename iterator_traits<T>::pointer_type,
typename iterator_traits<T>::iterator_category(五种)

7.3 Output Iterator
强化自： Assignable
还要求：前置operator++， 后置operator++(int)，typename iterator_traits<T>::iterator_category(五种)
注：由于operator*并不回返回有用的值，所以没为value_type

7.4 Forward Iterator
强化自：Input Iterator, Output Iterator, Default constructible

7.5 Bidirectional Iterator
强化自：Forward Iterator
还要求：operator--, operator--(int)

7.5 Radom Access Iterator
强化自：Bidirectional Iterator, Strict weakly comparable
还要求：operator+, operator+=, operator-, operator-=, operator[]


第8章 Function Objects(函数对象)

8.1 基本的Function Objects
1) Generator: 		强化自: Assignable 	int (*)() 是Generator的一个Model
2) Unary Function: 	强化自: Assignable	int (*)(double) 是Unary Function的一个Model
3) Binary Function: 	强化自: Assignable	int (*)(double, short) 是Unary Function的一个Model

8.2 Adaptable Function Objects
1) Adaptable Generator: 	强化自: Generator: 	还要求: result_type;
2) Adaptable Unary Function	强化自: Unary Function	还要求: result_type, argument_type
3) Adaptable Binary Function 	强化自: Binary Function	还要求: result_type, first_argument_type, second_argument_type
注: 函数指针不是Adaptable Function Objects的Model, 因为其内未定义result_type

8.3 Predicates
1) Predicate 			强化自: Unary Function, 				但限制 返回值必须可转化为bool
2) Binary Predicate 		强化自: Binary Function, 				但限制 返回值必须可转化为bool
3) Adaptable Predicate 		强化自: Predicate, Adaptable Unary Function, 		还要求 result_type必须可转化为bool, argument_type 
4) Adaptable Binary Predicate 	强化自: Binary Predicate, Adaptable Binary Function	还要求 result_type必须可转化为bool, first_argument_type, second_argument_type
5) Strick Weak Ordering		强化自: Binary Predicate,				但限制 第一个参数与第二个参数类型相同
注：Strick Weak Ordering与Strict weakly comparable形成互补，凡使用次序的算法一般成对出现（一个版本使用operator<， 另一版本使用function object） 

8.4 特化的Concept
1) Radom Number Generator	强化自：Unary Function，但限制参数为整数N，返回值为[0, N)之间的任一整数
2) Hash Function		强化自：Unary Function，但限制返回值必须为size_t
注：Hash Function一般要求返回某一个值的几率与返回其它值的机率大约相等，Hash Function并不知道Hash Associative Container所使用的bucket(桶子)的个数


第9章 Container(容器)

注：Container是一种容纳其它Objects的Object, 每个Container都具有一个相关的iterator类型，可用来遍历元素，
容器内元素的生命周期不会超过容器的生命周期。

9.1 General Container Concepts
1) Container
强化自：Assignable
还要求：value_type, reference, const_reference, pointer, const_pointer, iterator, const_iterator, difference_type, size_type
~(), begin(), end(), size(), max_size(), empty(), swap()

2) Forward Container
强化自：Container, Equality Comparable, LessThan Comparable
限制：其Iterator为Forward Iterator的一个Model

3) Reversible Container
强化自: Forward Container
还要求: reverse_iterator, const_reverse_iterator, rbegin(), rend()
限制：其Iterator为Bidirectional Iterator的一个Model

4) Radom Access Container
强化自: Reversible Container
还要求: operator[]
限制：其Iterator为Radom Access Iterator的一个Model

9.2 Sequence(顺序容器)
1) Sequence 			强化自: Forward Container, Default Construtible 还要求: insert(), erase(), front()
2) Front Insertion Sequence	强化自: Sequence				还要求: front(), push_front(), pop_front()
3) Back Insertion Sequece	强化自: Sequence				还要求: back(), push_back(), pop_back()

9.3 Associative Containers
1) Associative Container
强化自: Forward Container
还要求: key_type, find(key), count(key), equal_range(key), erase()

2) Unique Associative Container 	强化自: Associative Container 	还要求: insert() 限制: key不能相同
3) Multiple Associative Container	强化自: Associative Container	还要求: insert()

4) Simple Associative Container 	强化自: Associative Container 	还要求: key_type, iterator
5) Pair Associative Container		强化自: Associative Container 	还要求: key_type, mapped_type, value_type(即pair<const key_type, mapped_type>)

6) Sorted Associative Container		强化自: Associative Container， Reversiable Container 
					还要求: key_compare(), value_compare(), key_comp(), value_comp(), lower_bound(key), upper_bound(key), equal_range(key), insert()
7) Hashed Associative Container		强化自: Associative Container
					还要求: hasher(), key_equal(), hash_funct(), key_equ(), bucket_count(), resize() 

8) Allocator
强化自: Equality Comparable, Default Constructible
还要求: value_type, pointer, const_pointer, reference, const_reference, difference_type, size_type, rebind<U>::other, 
	allocate(), deallocate(), max_size(), construct(), destroy(), address()


第三篇	算法与类
----------------------------------------------------------------------------------------------------

第10章 基本组件

10.1 Pair
pair<T1, T2>
first_type					// T1的类型
econd_type					// T2的类型
pair(const T1& x, const T2& y)			// 构造 x构造出first, y构造出second
pair(const pair&)				// 拷贝构造
pair(const pair<U1, U2>& p)			// T1具有单参数(其类型为U1), T2具有单参数(其类型为U2)
first						// 代表pair第一元素
second						// 代表pair第二元素
bool operator==(const pair&, const pair&)	// 比较相等性
bool operator<(const pair&, const pair&)	// 依次比较first, second
make_pair(const T1& x, const T2& y)		// 构造pair的工具函数，相当于pair<T1, T2>(x, y)

10.2 Iterator基本要素(Iterator Primitives)
	
template<class Iterator>				// 其成员见7.2
iterator_traits<Iterator>				// 

templae <class InputIterator>				// 求距离
InputIterator::difference_type distance(InputIterator, InputIterator)

template<class InputIterator, class Distance>		// 将i累加n步距离
void advance(InputIterator& i, Distance n)		//

iterator<Category, T, Distance, Pointer, Reference>	// Iterator Base Class

10.3 Allocator
allocator<T>						// 见9.3.8

以下三个函数操作未初始化内存（与copy,fill, fill_n有类似理解）
// 拷贝
template<class InputIterator, class ForwardIterator> 
ForwardIterator uninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result)

// 填充
template<class ForwardIterator, class T> 
void uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& value)

// 填充n个
template<class ForwardIterator, class Size, class T> 
uninitialized_fill_n(ForwardIterator first, Size n, const T& value)

以下两个函数分配和释放临时内存
template<class T> pair<T*, ptrdiff_t> get_temporary_buffer(trdiff_t n);
template<class T> void return_temporary_buffer(T* p);

第11章 不改变操作对象之内容的算法
第12章 会改变操作对象之内容的算法
第13章 排序与查找

第14章 Iterator Classes(迭代器类)

14.1 Insert Iterators
front_insert_iterator<FrontInsertionSequence> 	插入到序列的头部
back_insert_iterator<BackInsertionSequence>	插入到序列的尾部
insert_iterator<Container>			播入到容器的某个iterator前

14.2 Stream Iterators
istream_iterator<T>
ostream_iterator<T>
istreambuf_iterator<T>
ostreambuf_iterator<T>

14.3 reverse_iterator
14.4 raw_storage_iterator
	
第15章 Function Object class
第16章 Container Classes(容器类)