1. Property Tree (<boost/property_tree/ptree.hpp>)
---------------------------------------------------------------------------------------------------
1) 概念上，Property Tree是一种通用的数据结构(可用来表示JSON, XML, INI，INFO数据元素)，其node定义如下：
struct ptree
{
   data_type data;                          // 与node关联的data
   list< pair<key_type, ptree> > children;  // child列表，每个child类型为pair<key_type, ptree>, key_tye通常表示node name，注意到这是递归定义
};
其中，data_type和key_type往往定义为std::string或std::wstring

2) ptree实质上是basic_ptree模板的一个实例,　定义如下：　
typedef basic_ptree<string, string> ptree;

basic_ptree可看成一个container, 有3个模板参数, 定义如下：
template<typename Key, typename Data, typename KeyCompare> class basic_ptree;
其中, Key表示child的key类型, Data表示node的数据类型, KeyCompare表示key比较函数（通常使用缺省版本）

3) basic_ptree中有很多操作children列表的方法（类似于list的相应方法), 常见的如下：

basic_ptree();                                      // 缺省构造
explicit basic_ptree(const data_type &);            // 由data构造
basic_ptree(const self_type &);                     // 拷贝构造
self_type & operator=(const self_type &);           // 拷贝赋值

size_type size() const;                             // children数目
bool empty() const;                                 // children列表是否为空
iterator begin();                                   // children列表开始(当然还有返回const_iterator的版本，还有rbegin()版本) 
iterator end();                                     // children列表结束
iterator insert(iterator, const value_type &);      // 插入child (value_type定义为pair<key_type, ptree>)
iterator erase(iterator);                           // 删除child
iterator push_front(const value_type &);            // 向list头增加child
iterator push_back(const value_type &);             // 向list尾增加child
self_type& get_child(const path_type &);                                  // 依照path来获取child, path不存在会抛异常, 注： self_type定义为basic_ptree
self_type& get_child(const path_type &, const self_type &) const;         // 依照path来获取child, path不存在返回第二个参数指定的值
self_type& put_child(const path_type &, const self_type &);               // 添加或更新child(path不存在表示添加child，否则表示更新已存在的child)
self_type& add_child(const path_type &, const self_type &);               // 添加child(向list尾部添加)

4) basic_ptree中访问data的方法：
get()                               // 获取child的data
put()                               // 添加或修改child的data
add()                               // 添加child的data

data_type& data();                  // 返回node的data(还有返回const data_type&的版本)
Type get_vaue()                     // 获取node的data, 并将其转化为Type类型（此为模板成员函数，下同）
put_value(const Type & value)       // 设置node的data, Type会转化为data_type

5) JSON解析
原始JSON格式：
{
   "menu":
   {
      "foo": true,
      "bar": "true",
      "value": 102.3E+06,
      "popup":
      [
         {"value": "New", "onclick": "CreateNewDoc()"},
         {"value": "Open", "onclick": "OpenDoc()"},
      ]
   }
}

转为为Property Tree后的格式：
menu
{
   foo true
   bar true
   value 102.3E+06
   popup
   {
      ""
      {
         value New
         onclick CreateNewDoc()
      }
      ""
      {
         value Open
         onclick OpenDoc()
      }
   }
}
转化规则：
JSON object映射为node的children, object的每个属性 (key: value）映射为一个表示child的pair<key, value>  
JSON array 映射为node的children, object的每个元素 (element) 映射为为一个表示child的pair<"", element>
JSON value 映射为node的data
注意，Property Tree并不一定能映射为JSON对象（例如data和children都不为空的Property Tree不能映射为JSON对象）

6) 访问Property Tree
3种get方式（pt类型为ptree）:
float v = pt.get<float>("a.path.to.float.value");   // 通过path访问(默认情况下.表示path的层级)，如果path不存在，抛异常
float v = pt.get("a.path.to.float.value", -1.f);    // 非异常版本，path不存在时返回第2个参数给定的值, 返回类型由第2个参数的类型推导
boost::optional<float> v = pt.get_optional<float>("a.path.to.float.value");  // 返回boost::optional
2种set方式：
pt.put("a.path.to.float.value", 3.14f);             // path不存在则添加新的node
pt.put("a.path.to.float.value", 2.72f);             // path存在则重写
pt.add("a.path.to.float.value", 3.14f);             // 添加一个新的node（即使指定的path已经存在） 

此外还有get_value/put_value用于get/set node的data, 所以无须指定path.

2. Lexical Cast (<boost/lexical_cast.hpp>)
---------------------------------------------------------------------------------------------------
1) 简介 
lexical_cast是一个函数模板，用于将Source类型转化为Target类型

template<typename Target, typename Source>              
Target lexical_cast(const Source& src);

Source类型需满足条件：　std::ostream << src 或　std::wostream << src
Target类型需满足条件：　1) std::istream >> dst 或 std::wistream >> dst, 2)Target对象可拷贝, 3)Target对象可缺省构造

注：转换失败时抛出bad_lexical_cast异常


2) 示例代码：
int x = boost::lexical_cast<int>("100");                // const char* 转换为int
std::string y = boost::lexical_cast<std::string>(x);　   // int转换为std::string

struct CX {　int x;　};
struct CY {　std::string y;　};
std::ostream& operator << (std::ostream& os, const CX& cx) {　os << cx.x;　return  os;　}
std::istream& operator >> (std::istream& is, CY& cy) {　is >> cy.y;　return  is;　}

CY cy = boost::lexical_cast<CY>(cx);                    // 自定义类型CX到CY的转换








