-----------------------------------googletest基本应用-----------------------------------
0.官方网站
	http://code.google.com/p/googletest/ 
1.基本概念（Basic Concepts）
	test             	----测试
	test case					----测试实例，可包含多个测试
	test program			----测试程序，可包含多个测试实例
2.基本断言（Basic Assertions）
	ASSERT_TRUE(condition);		EXPECT_TRUE(condition);		condition is true  
	ASSERT_FALSE(condition);  EXPECT_FALSE(condition);  condition is false
	ASSERT_* 表示致命错误（fatal failure），发生后从当前函数返回
	EXPECT_* 表示非致命错误（nonfatal failure），发生后允许函数继续执行，以便检查更多的错误
3.二元比较（Binary Comparison）
	ASSERT_EQ(expected, actual); 	EXPECT_EQ(expected, actual); 	expected == actual  
	ASSERT_NE(val1, val2);  			EXPECT_NE(val1, val2);  			val1 != val2  
	ASSERT_LT(val1, val2);  			EXPECT_LT(val1, val2);  			val1 < val2  
	ASSERT_LE(val1, val2);  			EXPECT_LE(val1, val2);  			val1 <= val2  
	ASSERT_GT(val1, val2);  			EXPECT_GT(val1, val2);  			val1 > val2  
	ASSERT_GE(val1, val2);  			EXPECT_GE(val1, val2);  			val1 >= val2 
	val1为期望值，val2为实际值（一般为表达式），按此约定以便gtest错误消息的优化
	val1和val2必须具有可比性（支持比较操作符），必须支持流ostream操作符<<
4 字符串比较
	ASSERT_STREQ(expected_str, actual_str);  		EXPECT_STREQ(expected_str, actual_str);  			the two C strings have the same content  
	ASSERT_STRNE(str1, str2);  									EXPECT_STRNE(str1, str2);  										the two C strings have different content  
	ASSERT_STRCASEEQ(expected_str, actual_str); EXPECT_STRCASEEQ(expected_str, actual_str);  	the two C strings have the same content, ignoring case  
	ASSERT_STRCASENE(str1, str2); 							EXPECT_STRCASENE(str1, str2);  								the two C strings have different content, ignoring case  
	CASE表示忽略大小写比较, 可比较宽字符C串（wchar_t*），失败时错误消息以UTF-8格 式输出
5 简单测试（Simple Tests）
	TEST(test_case_name, test_name) {
 	... test body ...
	}
	TEST()宏定义了一个没有返回值的C函数
	test_case_name表示测试实例名
	test_name表示测试名
	测试阶乘的例子:   
	
  // 待测函数
	// Returns the factorial of n
	int Factorial(int n);  

  // 测试实例
	// Tests factorial of 0.
	TEST(FactorialTest, HandlesZeroInput) {
	  EXPECT_EQ(1, Factorial(0));
	}
	
	// Tests factorial of positive numbers.
	TEST(FactorialTest, HandlesPositiveInput) {
	  EXPECT_EQ(1, Factorial(1));
	  EXPECT_EQ(2, Factorial(2));
	  EXPECT_EQ(6, Factorial(3));
	  EXPECT_EQ(40320, Factorial(8));
	}
7 测试夹具（Test Fixtures），多个测试共享相同的数据对象
	TEST_F(test_case_name, test_name) {
 	... test body ...
	}
	test_case_name需继承于::testing::Test
	添加构造函数或重写其虚函数SetUp()，	在其中写被测试对象的初始化代码
	添加析构函数重写其虚函数TearDown(), 在其中写被测试对象的撤销代码
	测试队列的例子:
	
	// 待测类
	template <typename E> // E is the element type.
	class Queue {
		public:
		Queue();
		void Enqueue(const E& element);
		E* Dequeue(); // Returns NULL if the queue is empty.
		size_t size() const;
	};
	
	// 测试实例
	class QueueTest : public ::testing::Test {
		protected:
			virtual void SetUp() {
			  q1_.Enqueue(1);
			  q2_.Enqueue(2);
			  q2_.Enqueue(3);
			}
			
			// virtual void TearDown() {}
			
			Queue<int> q0_;
			Queue<int> q1_;
			Queue<int> q2_;
	};
	
	TEST_F(QueueTest, IsEmptyInitially) {
	  EXPECT_EQ(0, q0_.size());
	}
	
	TEST_F(QueueTest, DequeueWorks) {
	  int* n = q0_.Dequeue();
	  EXPECT_EQ(NULL, n);
	
	  n = q1_.Dequeue();
	  ASSERT_TRUE(n != NULL);
	  EXPECT_EQ(1, *n);
	  EXPECT_EQ(0, q1_.size());
	  delete n;
	
	  n = q2_.Dequeue();
	  ASSERT_TRUE(n != NULL);
	  EXPECT_EQ(2, *n);
	  EXPECT_EQ(1, q2_.size());
	  delete n;
	}
	
	测试运行步骤：
	1.构造一个QueueTest对象(记为t1)
	2.调用t1.SetUp()
	3.在t1上运行测试IsEmptyInitially 
	4.调用t1.TearDown
	5.t1析构
	6.构造另一个QueueTest对象t2，重复上述步骤在t2上运行测试DequeueWorks

8 调用（激活）测试（Invoking the Tests）
	通过宏RUN_ALL_TESTS()调用所用测试, 其所做的工作如下：
	1)保存gtest全局状态标志（Saves the state of all Google Test flags）
	2)为第1个测试创建一个fixture对象（Creates a test fixture object for the first test）
	3)通过SetUp()进行初始化（Initializes it via SetUp()）
	4)运行fixture对象上的第1个测试（Runs the test on the fixture object）
	5)通过SetUp()进行清理（Cleans up the fixture via TearDown()）
	6)删除fixture对象（Deletes the fixture）
	7)恢复gtest全局状态标志（Restores the state of all Google Test flags） 
	8)对下一个测试重复上述步骤, 直到所有的测试运行完毕（Repeats the above steps for the next test, until all tests have run）
	main函数的写法如下：
	int main(int argc, char **argv) {
	  ::testing::InitGoogleTest(&argc, argv);      // 依据传入参数初始化gtest
	  return RUN_ALL_TESTS();                      // 调用所有测试
	}
	Windows环境下，InitGoogleTest也支持宽子符串，因此程序可在UNICODE模式下编译
	
-----------------------------------googletest高级应用-----------------------------------
9 更多断言
	1)显式成功或失败(Explicit Success and Failure)
	SUCCEED();     		成功(目前无用户可见输出)
	FAIL();    				致命错误(fatal failure )   
	ADD_FAILURE();    致命错误(nonfatal failure)
	2)异常断言(Exception Assertions)  
	ASSERT_THROW(statement, exception_type);  EXPECT_THROW(statement, exception_type);  statement throws an exception of the given type  
	ASSERT_ANY_THROW(statement);  						EXPECT_ANY_THROW(statement);  						statement throws an exception of any type  
	ASSERT_NO_THROW(statement);  							EXPECT_NO_THROW(statement);  							statement doesn't throw any exception  
	ASSERT_THROW(statement, exception_type)断言语句statement抛出类型为exception_type异常，如果抛出则运行成功，否则表示运行失败
	3）判定异常（Predicate Assertions）
	ASSERT_PRED1(pred1, val1);  			EXPECT_PRED1(pred1, val1);  			pred1(val1) returns true  
	ASSERT_PRED2(pred2, val1, val2);  EXPECT_PRED2(pred2, val1, val2);  pred2(val1, val2) returns true 
	4）浮点比较（Floating-Point Comparison）
	ASSERT_FLOAT_EQ(expected, actual);  	EXPECT_FLOAT_EQ(expected, actual);  	the two float values are almost equal  
	ASSERT_DOUBLE_EQ(expected, actual);  	EXPECT_DOUBLE_EQ(expected, actual);  	the two double values are almost equal
	ASSERT_NEAR(val1, val2, abs_error);  	EXPECT_NEAR(val1, val2, abs_error);   the difference between val1 and val2 doesn't exceed the given absolute error    
  5)浮点判定格式函数（Floating-Point Predicate-Format Functions）
  EXPECT_PRED_FORMAT2(::testing::FloatLE, val1, val2);
	EXPECT_PRED_FORMAT2(::testing::DoubleLE, val1, val2);
	6）Windows HRESULT断言（Windows HRESULT assertions）
	ASSERT_HRESULT_SUCCEEDED(expression);  	EXPECT_HRESULT_SUCCEEDED(expression);  	expression is a success HRESULT  
	ASSERT_HRESULT_FAILED(expression);  		EXPECT_HRESULT_FAILED(expression);  		expression is a failure HRESULT
	7）类型断言(Type Assertions)
	::testing::StaticAssertTypeEq<T1, T2>(); 
	T1, T2类型不同时会产生编译错误
	template <typename T> class Foo {
	 public:
	  void Bar() { ::testing::StaticAssertTypeEq<int, T>(); }
	};the code: 
	
	void Test1() { Foo<bool> foo; }            // 不产生编译错误, 因为Foo<bool>::Bar()未实例化
	void Test2() { Foo<bool> foo; foo.Bar(); } // 产生编译错误
	8)断言放置（Assertion Placement）
	a.产生致命（fatal failure） 错误的断言(FAIL* and ASSERT_*) 只能放置在返回void的函数体内
	  不能放在返回非void的函数体内, 否则产生编译错误“error: void value not ignored as it ought to be". 
	b.产生非致命（nofatal failure） 错误的断言（ADD_FAILURE* and EXPECT_*)无此限制
	c.构造函数中不使用致命（fatal failure）错误的断言的理由：可能导致对象的构造或析构不完全。
10 死亡测试（Death Tests）
	ASSERT_DEATH(statement, regex`);  					EXPECT_DEATH(statement, regex`);  					statement crashes with the given error  
	ASSERT_EXIT(statement, predicate, regex`);  EXPECT_EXIT(statement, predicate, regex`);  statement exits with the given error and its exit code matches predicate 
	statement ----引起进程终止的语句（包括复合语句）
	predicate ----函数（或函数对象：function object）比较一个整数退出码，返回类型bool            
	regex			----正则表达式，期望匹配statement语句输出到stderr的内容
	::testing::ExitedWithCode(exit_code)      // 比较退出码
	::testing::KilledBySignal(signal_number)  // 比较退出信号(Windows环境下不可用)
	例子1：
	// 判定调用Foo(5)引起进程终止，并在stderr上输出"Error on line .* of Foo()"相匹配的内容
	TEST(My*DeathTest*, Foo) {
	  // This death test uses a compound statement.
	  ASSERT_DEATH({ int n = 5; Foo(&n); }, "Error on line .* of Foo()");
	}
	// 判定调用NormalExit()引起进程退出，退出码为0， 并在stderr上输出"Success"
	TEST(MyDeathTest, NormalExit) {
	  EXPECT_EXIT(NormalExit(), ::testing::ExitedWithCode(0), "Success");
	}
	// 判定调用KillMyself()引起进程终止，终止信号为SIGKILL， 并在stderr上输出"Sending myself unblockable signal"
	TEST(MyDeathTest, KillMyself) {
	  EXPECT_EXIT(KillMyself(), ::testing::KilledBySignal(SIGKILL), "Sending myself unblockable signal");
	}
	实现原理：产生一个子进程执行statement语句。
	POSIX系统：分"fast"和“threadsafe"两种实现，默认为"fast"
	Windows系统：调用CreateProcess()，类似于”threadsafe"
	可通过::testing::FLAGS_gtest_death_test_style = "threadsafe"或命令行--gtest_death_test_style来指定采用哪种实现
	例子2：
	TEST(MyDeathTest, TestOne) {
	  ::testing::FLAGS_gtest_death_test_style = "threadsafe";
	  // This test is run in the "threadsafe" style:
	  ASSERT_DEATH(ThisShouldDie(), "");
	}
	
	TEST(MyDeathTest, TestTwo) {
	  // This test is run in the "fast" style:
	  ASSERT_DEATH(ThisShouldDie(), "");
	}
	
	int main(int argc, char** argv) {
	  ::testing::InitGoogleTest(&argc, argv);
	  ::testing::FLAGS_gtest_death_test_style = "fast";
	  return RUN_ALL_TESTS();
	}
11 子过程中使用断言（Using Assertions in Sub-routines）
	a.添加TRACE到断言（Adding Traces to Assertions）
	SCOPED_TRACE(message);
	message ----任意可输出到的ostream内容, 一般用于子进程开始出，会在引起失败消息后面加上用户的内容
	b.断言没有非致命性错误(语句statement如果包含ASSERT_*或FAIL()，断言它们不会执行失败)
	ASSERT_NO_FATAL_FAILURE(statement);  EXPECT_NO_FATAL_FAILURE(statement);  statement doesn't generate any new fatal failures in the current thread 
	c.判定致命性错误
	::testing::Test中的HasFatalFailure()可用于判断当前测试中是否有致命性错误
	例子：
	TEST(FooTest, Bar) {
	  Subroutine();
	  // Aborts if Subroutine() had a fatal failure.
	  if (HasFatalFailure())
	    return;
	  // The following won't be executed.
	  ...
	} 
  如果作用域在TEST() , TEST_F()外，则需加::testing::Test::前辍，如：
  if (::testing::Test::HasFatalFailure())
  	return;
12 日志输出额外信息（Logging Additional Information）
	RecordProperty("key", value)
	value ----可以是C串或32位整数, XML文件中输出value最近一次的值
	TEST_F(WidgetUsageTest, MinAndMaxWidgets) {
	  RecordProperty("MaximumWidgets", ComputeMaxUsage());
	  RecordProperty("MinimumWidgets", ComputeMinUsage());
	}
	输出的XML文件：
	...
	  <testcase name="MinAndMaxWidgets" status="run" time="6" classname="WidgetUsageTest"
	            MaximumWidgets="12"
	            MinimumWidgets="9" />
	...
	
13 同一个测试实例的多个测试之间共享资源（Sharing Resources Between Tests in the Same Test Case）
	 如前7所述，为使测试独立和容易调试gtest为每个测试创建一个新的fixture对象，但有时想要整个实例共享资源
	 例子：
	 class FooTest : public ::testing::Test {
	 protected:
	  // 针对每个测试实例的初始化
	  // Per-test-case set-up.
	  // Called before the first test in this test case.
	  // Can be omitted if not needed.
	  static void SetUpTestCase() {
	    shared_resource_ = new ...;
	  }
	
	  // 针对每个测试实例的清理
	  // Per-test-case tear-down.
	  // Called after the last test in this test case.
	  // Can be omitted if not needed.
	  static void TearDownTestCase() {
	    delete shared_resource_;
	    shared_resource_ = NULL;
	  }
	
	  // 也可定义针对每个测试的初始化和清理
	  // You can define per-test set-up and tear-down logic as usual.
	  virtual void SetUp() { ... }
	  virtual void TearDown() { ... }
	
	  // Some expensive resource shared by all tests.
	  static T* shared_resource_;
	};
	
	T* FooTest::shared_resource_ = NULL;
	
	TEST_F(FooTest, Test1) {
	  ... you can refer to shared_resource here ...
	}
	TEST_F(FooTest, Test2) {
	  ... you can refer to shared_resource here ...
	}
14 全局初始化和清理（Global Set-Up and Tear-Down）----针对测试程序为言
	1)继承于::testing::Environment的子类
		class Environment {
		 public:
		  virtual ~Environment() {}
		  // Override this to define how to set up the environment.
		  virtual void SetUp() {}
		  // Override this to define how to tear down the environment.
		  virtual void TearDown() {}
		};
	2)用以下函数注册一个Environment
	  Environment* AddGlobalTestEnvironment(Environment* env);
	3)AddGlobalTestEnvironment()应该在RUN_ALL_TESTS()前调用, 可调用多次，
	  其SetUp顺次依次执行，TearDown倒序依次执行
15 参数化值测试（Value Parameterized Tests）
  例子：
  
	class FooTest : public ::testing::TestWithParam<const char*> {
	  // You can implement all the usual fixture class members here.
	  // To access the test parameter, call GetParam() from class
	  // TestWithParam<T>.
	};
	
	// 注意宏为TEST_P
	TEST_P(FooTest, DoesBlah) {
	  // Inside a test, access the test parameter with the GetParam() method
	  // of the TestWithParam<T> class:
	  EXPECT_TRUE(foo.Blah(GetParam()));
	  ...
	}
	
	TEST_P(FooTest, HasBlahBlah) {
	  ...
	}
	
	// INSTANTIATE_TEST_CASE_P实例化测试实例
	INSTANTIATE_TEST_CASE_P(
		InstantiationName,                             // 实例化名称
		FooTest,                                       // 测试实例名
		::testing::Values("meeny", "miny", "moe"));    // 参数产生器（parameter generators）
		
	gtest的参数产生器：
	Range(begin, end[, step])  										Yields values {begin, begin+step, begin+step+step, ...}. The values do not include end. step defaults to 1.  
	Values(v1, v2, ..., vN)  											Yields values {v1, v2, ..., vN}.  
	ValuesIn(container) and ValuesIn(begin, end)  Yields values from a C-style array, an STL-style container, or an iterator range [begin, end).  
	Bool()  																			Yields sequence {false, true}.  
	Combine(g1, g2, ..., gN)  										Yields all combinations (the Cartesian product for the math savvy) of the values generated by the N generators. 
																								This is only available if your system provides the <tr1/tuple> header. 
																								If you are sure your system does, and Google Test disagrees, you can override it by defining GTEST_HAS_TR1_TUPLE=1. 
																								See comments in include/gtest/internal/gtest-port.h for more information.
16 参数化类型测试（Type-Parameterized Tests ）
   例子：
   1）定义一个fixture类模板
		template <typename T>
		class FooTest : public ::testing::Test {
		  ...
		};
	2）声明参数化参数测试实例
		TYPED_TEST_CASE_P(FooTest);
	3）定义参数化测试，注意此处用宏TYPED_TEST_P
		TYPED_TEST_P(FooTest, DoesBlah) {
		  // Inside a test, refer to TypeParam to get the type parameter.
		  TypeParam n = 0;
		  ...
		}
		
		TYPED_TEST_P(FooTest, HasPropertyA) { ... }
	4）注册测试
		REGISTER_TYPED_TEST_CASE_P(FooTest, DoesBlah, HasPropertyA);
	5）利用typedef实例化
		typedef ::testing::Types<char, int, unsigned int> MyTypes;  // 定义类型列表
		INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);
17 测试私有代码（Testing Private Code）
	 例子：
	 	// foo.h
		#include <gtest/gtest_prod.h>
		
		// Defines FRIEND_TEST.
		class Foo {
		  ...
		 private:
		  FRIEND_TEST(FooTest, BarReturnsZeroOnNull);
		  int Bar(void* x);
		};
		
		// foo_test.cc
		...
		TEST(FooTest, BarReturnsZeroOnNull) {
		  Foo foo;
		  EXPECT_EQ(0, foo.Bar(NULL));
		  // Uses Foo's private member Bar().
		}
18 捕获错误（Catching Failures）
	 包括<gtest/gtest-spi.h>头文件
	 EXPECT_FATAL_FAILURE(statement, substring);      // 断言致命错误消息包含子串substring
	 EXPECT_NONFATAL_FAILURE(statement, substring);   // 断言非致命错误消息包含子串substring
	 捕获多线程的断言
	 EXPECT_FATAL_FAILURE_ON_ALL_THREADS(statement, substring);  
	 EXPECT_NONFATAL_FAILURE_ON_ALL_THREADS(statement, substring); 


19 获取当前测试的名称（Getting the Current Test's Name）
	::testing::TestInfo类包含这此信息
	namespace testing {
	
	class TestInfo {
	 public:
	  // Returns the test case name and the test name, respectively.
	  //
	  // Do NOT delete or free the return value - it's managed by the
	  // TestInfo class.
	  const char* test_case_name() const;
	  const char* name() const;
	};
	} 
	调用current_test_info()可得到一个指向::testing::TestInfo的对象指针
	例子：
	// Gets information about the currently running test.
	// Do NOT delete the returned object - it's managed by the UnitTest class.
	const ::testing::TestInfo* const test_info =
	  ::testing::UnitTest::GetInstance()->current_test_info();
	printf("We are in test %s of test case %s.\n",
	       test_info->name(), test_info->test_case_name());
20 运行测试程序高级选项(Running Test Programs: Advanced Options)
   可用两种方式改变选项：
   1）直接在main函数中更改，如：
		int main(int argc, char** argv) {
		  // Disables elapsed time by default.
		  ::testing::GTEST_FLAG(print_time) = false;
		
		  // This allows the user to override the flag on the command line.
		  ::testing::InitGoogleTest(&argc, argv);
		
		  return RUN_ALL_TESTS();
		}
	2）通过命令行改变, 如：
		test_program --gtest_print_time = false
	3) 其它选项可通过命令行帮助查看
		test_program --help 或-h 或-? 或 /?



