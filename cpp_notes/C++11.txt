C++11
--------------------------------------------------------------------------------
C++基础技术
1)　Copy elision (https://en.wikipedia.org/wiki/Copy_elision)
Copy elision是一种编译优化技术，用于消除不必要的对象拷贝, RVO(Return value optimization)也可归为此类优化s
Copy elision应用的情况如：1) （函数返回的）临时对象的拷贝构造， 2) 异常对象拷贝构造
注：
a. Copy elision通常要求显示实现一个拷贝构造函数
b. gcc通过-fno-elide-constructors选项可禁止Copy elision优化

2) 变参模板（variadic template）
变参模板（函数或类）涉及到参数包（parameter packet），有两种参数包：
示例：
template <typename T, typename.. Args>
void f00(const T& t, const Args&... args)
模板参数包（template parameter packet）: 用typename...或class...指出Args是一个模板参数包
函数参数包（function parameter packet）: const Args&指出args是一个函数参数包（每个参数类型为const引用）

3) sizeof...
sizeof...()返回参数包中参数个数，如：
template <typname... Args> 
void g(Args... args) {
    cout << sizeof...(Args) << endl;    // 返回模板参数包中参数个数
    cout << sizeof...(args) << endl;    // 返回函数参数包中参数个数
}

4) 可变参数函数
<cstdarg>
va_list ap                                  // 构造一个空的valist, va_list可变参数类型（由实现决定）
va_start(va_list ap, paramN)                // 用参数paramN后的所有参数构造va_list对象（注：不包括paramN） 
type va_arg (va_list ap, type)              // 取回下一个参数，类型由type指定（如：int, double, ...），注：此宏不知道有多少个参数
va_end(va_list ap)                          // 与va_start配对使用，在调用函数返回之前必须调用
void va_copy(va_list dest, va_list src);    // c++11新增：拷贝src得到dest
示例代码：
void PrintFloats(int n, ...)　{
    int i;
    double val;
    va_list vl;
    va_start(vl,n);
    for (i=0;　i<n;　i++)　{
        val=va_arg(vl,double);
        printf ("[%.2f]　",val);
    }
    va_end(vl);
}
调用PrintFloats(3,3.14159,2.71828,1.41421)输出结果：
[3.14] [2.72] [1.41]
注：
1) va_arg不法知道参数的个数及每个参数的类型,　此类功能可通过参数的特定意义来实现　
2) printf vs. vprintf系列，
vprintf函数须接va_list，而printf则接一系列参数, 将va_list对象传给printf会导致问题。
int vprintf(const char* format, va_list arg);
int printf(const char* format, ... ); 

4) bitset
初始化bitset方法：
bitset<n> b     // b有n位，每位为0
bitset<n> b(u)  // b是(unsigned long long)u低n位的拷贝，如果u位数小于n，则高位为0
bitset<n> b(s, pos, m, one, zero)   // b是string s从pos位置开始m个字符的拷贝，m(缺省string::npos), one(缺省'1'), zero(缺省'0')
bitset<n> b(cp, pos, m, one, zero)  // 同上，从字符数组cp中拷贝，如果未指定m，cp必须是c风格字符串
注：若s或cp中包含one和zero以外的其它字符，则会抛出异常

bitset操作方法：
b.any()         // b中是否存在置位（为１）的二进制位
b.all()         // b中所有位都置位了吗？
b.none()        // b中所有位都没有置位吗？
b.count()       // b中已置位的位数

b.size()        // b中所有位的位数

b.test(pos)     // 测试pos位是否置位

b.set(pos, v)   // pos位设为v（true或false）
b.set()         // 所有位置位

b.reset(pos)    // pos位复位（为０） 
b.reset()       // 所有位复位

b.flip(pos)     // pos位翻转（０为１，１为０）
b.flip()        // 所有位翻转

b[pos]          // 访问pos位（true或false）
b.to_ulong()    // 转化为unsigned long (可能抛出异常)
b.to_ullong()   // 转化为unsigned long long (可能抛出异常)

1 基本术语
scalar type                 -- 标量类型-如int, double等简单类型(与复合类型如list, map等相对). 具有内建\非重载的operator+操作符的类型（指针, 成员指针, 枚举, std::nullptr_t）
move constructible type     -- 移动可拷贝类型。可右值引用拷贝构造。包括scalar类型和move constructible classes
move constructible classes  -- 移动可拷贝类。具有move构造或它的copy构造函数当作右值引用被调用（没有用delete指定其move constructor）
                               注：可拷贝构造类型(copy constructible type)也是move constructible type

--------------------------------------------------------------------------------
#include <type_traits>

struct A { };
struct B { B(B&&) = delete; };
...
std::cout << "int: " << std::is_scalar<int>::value << std::endl;
std::cout << "A: " << std::is_scalar<A>::value << std::endl;
std::cout << "A&: " << std::is_scalar<A&>::value << std::endl;
std::cout << "A*: " << std::is_scalar<A*>::value << std::endl;
std::cout << "int(int): " << std::is_scalar<int(int)>::value << std::endl;
std::cout << "int(*)(int): " << std::is_scalar<int(*)(int)>::value << std::endl;
...
std::cout << "int: " << std::is_move_constructible<int>::value << std::endl;
std::cout << "A: " << std::is_move_constructible<A>::value << std::endl;
std::cout << "B: " << std::is_move_constructible<B>::value << std::endl;
--------------------------------------------------------------------------------
int: true
A: false
A&: false
A*: true
int(int): false
int(*)(int): true
...
int: true
A: true
B: false
--------------------------------------------------------------------------------
注：c++11特性gcc下编译需加选项：-std=c++11或-std=gnu++11，std::thread可能需-lpthread

2 多线程（Multi-threading）
1) std::thread（头文件<thread>）
成员类型：
id                                          // 线程id
native_handle_type                          // 本地线程句柄

成员函数：   
thread();                                   // 缺省构造（未初始化）
template <class Fn, class... Args>
explicit thread (Fn&& fn, Args&&... args);  // 初始化（传入fn及其参数即可，忽略fn返回值）
thread (const thread&) = delete;            // 禁止拷贝
thread (thread&& x);                        // move构造
~thread();                                  // 析构（如果对象是joinable则调用std::terminate()终止程序）

thread& operator=(thread&& rhs)             // 赋值（当前thread对象赋值rhs，而rhs变成non-initialized）
thread& operator=(const thread&) = delete;  // 不能拷贝赋值

id get_id() const;                          // 获取线程id
native_handle_type native_handle();         // 获取本地线程句柄（native_handle_type结构的内容依赖具体实现）
bool joinable() const;                      // 判断是否joinable
void detach();                              // detach后thread对象变成non-joinable（不管了，让线程自己去运行吧）
void swap (thread& x);                      // 交换两个thead对象的内部状态
static unsigned hardware_concurrency();     // 返回hardware thread contexts数目（依赖具体平台），或者为0（如果不可计算或未定义）
注：
a）已初始化的(initialized）的thread对象是joinable, 有一个唯一的线程id
   缺省构造的thread对象是non-joinable, 它们共有同一个线程id
   调用join、detach或operator=后, joinable的thread对象会变成non-joinable.
b）对joinable的thread对象被析构、或赋值时会导致std::terminate()的调用（因为这时线程还没结束呢）

2) std::this_thread（关于当前线程的命名空间）
thread::id get_id();                        // 获取当前线程id
void yield();                               // 让步。提示系统调度（让其它线程运行吧）
template <class Clock, class Duration>      // sleep直到abs_time（time_point对象代表一个绝对时间点）
void sleep_until (const chrono::time_point<Clock,Duration>& abs_time);
template <class Rep, class Period>          // sleep一段时间rel_time（duration对象代表一个时间段）
void sleep_for (const chrono::duration<Rep,Period>& rel_time);

3）std::memory_order（内存顺序）
typedef enum memory_order {
    memory_order_relaxed,   // relaxed
    memory_order_consume,   // consume
    memory_order_acquire,   // acquire
    memory_order_release,   // release
    memory_order_acq_rel,   // acquire/release
    memory_order_seq_cst    // sequentially consistent
} memory_order;
待研究....

4）std::atomic_flag（即boolean的atomic对象）
atomic_flag() noexcept = default;                                       // 缺省构造
atomic_flag (const atomic_flag&T) = delete;                             // 禁止拷贝构造
bool test_and_set (memory_order sync = memory_order_seq_cst) volatile;  // 先测试flag是否被设置，再设置flag. 返回测试结果
bool test_and_set (memory_order sync = memory_order_seq_cst);           // 同上
注：ATOMIC_FLAG_INIT宏可用于初始化atomic_flag对象：std::atomic_flag f=ATOMIC_FLAG_INIT;
    是否构造时初始化的atomic_flag依赖具体执行

5）std::atomic（头文件<atomic>）
atomic() = default;	                        // 缺省构造
atomic (T val);                             // 初始化构造
atomic (const atomic&) = delete;            // 不能拷贝

void store (T val, memory_order sync = memory_order_seq_cst);           // 存储值
T load (memory_order sync = memory_order_seq_cst) const;                // 加载值 
operator T() const ;                                                    // 转换        
bool is_lock_free() const;                                              // 锁否
T exchange (T val, memory_order sync = memory_order_seq_cst);           // 交换，返回先前值
bool compare_exchange_weak()                                            // ...待解释...  
bool compare_exchange_strong()
T fetch_add (T val, memory_order sync = memory_order_seq_cst) ;         // 加另一个值，返回先前值
T fetch_add (ptrdiff_t val, memory_order sync = memory_order_seq_cst);  // 加一个偏移量，返回先前值 
T fetch_sub(...)                                                        // 减的类似功能
T fetch_and(...)
T fetch_or(...)
T fetch_xor(...)
operator++                                                              // 自增
operator--                                                              // 自减
operator+= -= &= |= （T val）                                           // 其它重载(容易理解)
operator+= -= （ptrdiff_t val val）                                     // 

6）<mutex>
-------------------------------------------------------------------------------
std::mutex（非循环互斥: 一个线程如果已对mutex对象加锁，再次lock或try_lock会产生死锁）
std::recursive_mutex（循环互斥: 与std::mutex相对，可对已加锁对象lock, 但unlock()必须调用同样多次,成员函数功能类似）
constexpr mutex();                                  // 构造
mutex (const mutex&) = delete                       // 禁止拷贝
void lock()                                         // 加锁
bool try_lock()                                     // 试加锁
void unlock()                                       // 解锁
native_handle_typ native_handle()                   // 本地句柄

std::timed_mutex（与std::mutex相同，除了增加以下两个成员）
std::recursive_timed_mutex（与std::timed_mutex相同，只不过非循环互斥而已罢了）
template <class Rep, class Period>
bool try_lock_for(const chrono::duration<Rep,Period>& rel_time);            // 一段时间内加锁
template <class Clock, class Duration>
bool try_lock_until(const chrono::time_point<Clock,Duration>& abs_time);    // 加锁到某个绝对时间点

总结起来就是：
std::mutex                      // 非循环（或递归）互斥对象
std::recursive_mutex            // 可循环（或递归）互斥对象
std::time_mutex                 // 非循环（或递归）互斥对象, 可以一段时间内（或直到某个时间点）加锁
std::recursive_timed_mutex      // 可循环（或递归）互斥对象，可以一段时间内（或直到某个时间点）加锁
-------------------------------------------------------------------------------
std::lock_guard(功能简单。构造时lock,析构时unlock)
explicit lock_guard(mutex_type& m);                 // 构造时传入mutex对象
lock_guard(mutex_type& m, adopt_lock_t tag);        // tag可以是adopt_lock采用当前锁(意思是，如果当前钱程已对m加锁，就不再加锁啦)
lock_guard(const lock_guard&) = delete;             // 禁止拷贝

std::unique_lock（强调对mutext的拥有（ownership）, 内部维护一个mutext指针和bool值指示当前线程是否拥有这个mutex）
有以下函数lock, unlock, try_lock, try_lock_for, try_lock_until, operator=, swap, 
mutex* release()                // 返回内部mutex对象指针，不管它啦
bool owns_lock() const;         // 是否lock了内部的mutex对象（unique_lock对象构造时，可以不传入mutex对象）
operator bool                   // 同上
mutex_type* mutex() const;      // 返回内部mutex对象指针
-------------------------------------------------------------------------------
std::condition_variable（条件变量）
condition_variable();                                       // 构造
~condition_variable()                                       // 析构，等待此条件的线程被通知
condition_variable (const condition_variable&) = delete     // 禁止拷贝

void wait (unique_lock<mutex>& lck);                        // 等待条件（内部lck.lock()的情况下, 即lock内部的mutex）
template <class Predicate>                                 
void wait(unique_lock<mutex>& lck, Predicate pred);         // 加条件等待。while (!pred()) wait(lck); pred返回true时才不再等，否则一直等下去咯
wait_for                                                    // 等待一个时间段
wait_until                                                  // 等待直到某个时间点
void notify_one()                                           // 通知一个阻塞线程
void notify_all()                                           // 通知所有阻塞线程

std::condition_variable_any功能与condition_variable类似，只是功能扩展啦，见下例：
template <class Lock> 
void wait (Lock& lck)  // lck不再仅限于unique_lock<mutex>啦，它可以是任意Lockable类型（定义了lock()，try_lock(), un_lock()的类型）
-------------------------------------------------------------------------------

7）<future>
此头文件包含一些涉及对值的同步访问, 这些值由provider来（在不同线程中）设置, 通过future访问。
每个provider与一个funture对象共享访问一个共享状态（即某种类型的一个值）
有效的future对象（缺省构造的future对象无效）关联一个共享状态，这些对象可以通过调用以3个函数来获得
async(..)
promise::get_future()
packaged_task::get_future()

Provider(提供者)包括：promise， packaged_task， async（函数）
Futures(获取者)包括： future shared_future
-------------------------------------------------------------------------------
class template<class T> std::future         // future关联类型为T的值（对引用和void进行了模板特化）

template <class T>  future;
future();                                   // 缺省构造（处于无效状态）
future (future&& x);                        // Move构造（获取x内的共享状态，x不再有效）
future (const future&) = delete;            // 禁止拷贝
~future();                                  // 析构时取消与其内部状态（T类型的值t）的联系，如果t的引用计数为0, 调用t的析构.

future& operator=(future&& rhs);            // Move赋值（类似滴，rhs不再有效）
future& operator=(const future&) = delete;  // 禁止拷贝赋值（理由显然滴, 因为禁止了拷贝构造）
    
shared_future<T> share();                   // 返回shared_future对象，原future对象不再有效（注: 无效的futrue对象调用此函数导致未定义行为）
T get();                                    // 等待当前线程直到其共享状态变成ready(由provider设置), 此函调用1次后，内部的共享状态t就会析构
bool valid() const;                         // 判断是否有效
void wait() const;                          // 等待当前线程直到其共享状态变成ready（内部状态不会析构）
future_status wait_for(...) const;          // 一段时间内等待, 返回值:ready - 等到啦，timeout - 超时啦, deferred - 不必等啦, 延迟滴东东
future_status wait_until(...) const;        // 等待某个时间点(你懂滴)

std::shared_future：顾名思义,就是可共享的future, 不同之处在于: 此对象可以拷贝或赋值，get()函数不会析构内部共享状态
-------------------------------------------------------------------------------
class template<class T> std::promise                // 与future相对，用来设置共享状态滴 
promise();                                          // 缺省
template <class Alloc>
promise (allocator_arg_t aa, const Alloc& alloc);   // 带Allocator的构造（如何分配内存的东东，很少使用）
promise (const promise&) = delete;                  // 禁止拷贝（自然也会禁止赋值）
promise (promise&& x);                              // 移动拷贝（自然x不再有效啦）

promise& operator=(promise&& rhs);                  // Move赋值
promise& operator=(const promise&) = delete;        // 禁止拷贝赋值（前面说过滴，因禁止拷贝构造）
future<T> get_future();                             // 获取future对象，只能调用1次。析构时如果状态还未ready或者set_exception(), 要抛异常broken_promise哦!

void set_value (const T& val);                      // 设置状态（如果T为void可不传参），设置后状态为ready啦
void set_exception (exception_ptr p);               // 设置异常，设置后状态为ready啦
void set_value_at_thread_exit (const T& val);       // 线程退出时才设置状态为ready（其实状态值已经被置，只是状态未ready, future.get()要等到线程结束喽！）
void set_exception_at_thread_exit(exception_ptr p); // 线程退出时才设置状态为ready，并抛异常
void swap (promise& x);                             // 交换
-------------------------------------------------------------------------------
template <class Ret, class... Args>                 // 类似promise，只不过它的参数是Callable类型, 内部维护两个东西：1）Ret类型的状态（与future共享用） 2)Callable的对象（或函数）
class packaged_task<Ret(Args...)>;                  // 顾名思义，就是对一个任务进行封装

packaged_task();                                    // 缺省构造（没有共享状态）
template <class Fn>
explicit packaged_task(Fn&& fn);                    // 传入Callable的fn构造（有状态喽）
template <class Fn, class Alloc>                    // 很少使用
explicit packaged_task(allocator_arg_t aa, const Alloc& alloc, Fn&& fn);
packaged_task(const packaged_task&) = delete;       // 禁止拷贝（或赋值）
packaged_task(packaged_task&& x) ;                  // Move拷贝（x不再有状态）
~packaged_task();                                   // 析构时（状态引用计数为0时才析构，Callable对象会析构）
void operator()(Args... args);                      // 调用这个Callable对象吧,其它线程future.get()等着结果呢（可能等到结果或异常）
void make_ready_at_thread_exit (args... args)       // 线程退出时才调用, 其它线程的future::get()只能等到结束喽
void reset();                                       // 重设共享状态（先前滴状态不管啦），这样又可以调用Callable对象喽
void swap (packaged_task& x);                       // 交换
-------------------------------------------------------------------------------
std::async （看看这函数模板吧）

template <class Fn, class... Args>
future<typename result_of<Fn(Args...)>::type> async (Fn&& fn, Args&&... args);

template <class Fn, class... Args>
future<typename result_of<Fn(Args...)>::type> async (launch policy, Fn&& fn, Args&&... args);



3 tuple(元组，可容纳不同类型元素)
template <class... Types> class tuple;

构造：
std::tuple<int,char> first;                             // default构造
std::tuple<int,char> second (first);                    // copy构造
std::tuple<int,char> third (std::make_tuple(20,'b'));   // move构造
std::tuple<long,char> fourth (third);                   // implicit conversion构造
std::tuple<int,char> fifth (10,'a');                    // initialization
std::tuple<int,char> sixth (std::make_pair(30,'c'));    // 通过pair构造 / move

赋值操作符（类似于构造）：
std::pair<int,char> mypair (0,' ');
std::tuple<int,char> a (10,'x');
std::tuple<long,char> b, c;
b = a;                                // copy 赋值
c = std::make_tuple (100L,'Y');       // move 赋值
a = c;                                // conversion 赋值
c = std::make_tuple (100,'z');        // conversion / move 赋值
a = mypair;                           // 通过 pair 赋值
a = std::make_pair (2,'b');           // 通过 pair /move 赋值

交换：
void swap (tuple& tpl) noexcept             // 成员版本
void swap (tuple& tpl, tuple& tp2) noexcept // 全局版本

访问元素(使用全局的std::get，没有相应成员版本)：
std::tuple<int,char> mytuple (10,'a');  
char b = std::get<0>(mytuple);          // 获取元素(返回指定索引元素的引用或const引用)
std::get<0>(mytuple) = 20;              // 设置元素(返回指定索引元素的引用)

获取元素个数（使用Helper类std::tuple_size）
std::tuple<int,char,double> mytuple (10,'a',3.14);
size_t count = std::tuple_size<decltype(mytuple)>::value;   //　获取元素个数 

获取元素类型（使用Helper类std::tuple_element）
auto mytuple = std::make_tuple (10,'a');
std::tuple_element<0,decltype(mytuple)>::type first = std::get<0>(mytuple);
std::tuple_element<1,decltype(mytuple)>::type second = std::get<1>(mytuple);

连接构造tuple(使用全局的std::tuple_cat函数模板)
std::tuple<float,std::string> mytuple (3.14,"pi");
std::pair<int,char> mypair(10,'a');
auto myauto = std::tuple_cat(mytuple, std::tuple<int,char>(mypair));

使用std::make_tuple（或std::tie）打包（或解包）
int myint;
char mychar;
std::tuple<int,float,char> mytuple = std::make_tuple (10, 2.6, 'a');   // packing
std::tie (myint, std::ignore, mychar) = mytuple;                       // unpacking

使用std::tuple_size获取tuple（或array，或pair）参数的个数
使用std::tuple_element获取tuple（或array，或pair）第n个参数的类型
std::tuple<int,char,double> mytuple (10,'a',3.14);
std::cout << std::tuple_size<decltype(mytuple)>::value;                 // 等价于std::cout << std::tuple_size<std::tuple<int,char,double>>::value;
std::tuple_element<0,decltype(mytuple)>::type first = std::get<0>(mytuple);


此外还有全局版本的比较操作符（从左到右依次比较元素）：　>, >=, <, <=, ==, !=


4　regex（正则表达式）
1) C++标准提供的正则表达式操作函数的相关参数：
目标序列(Target sequence或subject）:　表示从中搜索正则表达式的序列，可用两个iterator，或c-string, 或string表示 
正则表达式（Regular expression 或pattern）: 正则表达式（ECMAScript语法）, 必须是basic_regex对象（如regex）, 由字符串构造
匹配数组（Matches array）: 用于保存匹配结构（如cmatch和smatch）
替换字符串（Replacement string）: 用于替换匹配的字符串（ECMAScript语法）
注：
a. gcc-4.8.x不支持正则表达式，gcc-4.9以后支持正则表达式
b. 缺省使用ECMAScript语法（参考：http://www.cplusplus.com/reference/regex/ECMAScript/），但可通过flag设置

2) C++标准主要提供3个正则表达式操作(template)函数：
regex_match()             // 匹配序列
regex_search()            // 搜索序列
regex_replace()           // 替换序列

这些函数的参数和返回值为如下类型：
basic_regex               // 正则表达式(class template)
match_results             // 匹配结果(class template)　
sub_match               　　// 子匹配结果(class template)
regex_traits              // 相关Trait　(class template)
regex_error               // 相关异常(class)

这些template类型有如下实例化
typedef basic_regex<char>                       regex;          // 正则表式
typedef match_results<const char*>              cmatch;        　// c-string风格匹配结果　
typedef match_results<string::const_iterator>   smatch;         // string风格匹配结查
typedef sub_match<const char*>                  csub_match;    　// c-string风格子匹配结果
typedef sub_match<string::const_iterator>       ssub_match;    　// string风格子匹配结果 

注：把char换成wchar_t，把string换成wstring可得到宽字符版本：wcmatch, wsmatch, wcsub_match, wssub_match

3) match_results（表示匹配结果, 相当于sub_match的container, 每个sub_match元素为const-qualified）
match_results可作为regex_match, regex_search的参数，返回所有sub_match, 主要方法：

empty()             // 是非为空
size()              // sub_match数目
begin()/end()       // 指向sub_match的match_results::iterator 
cbegin()/cend()     // 指向sub_match的match_results::const_iterator
operator[i]         // 返回第i个sub_match
prefix()            // 返回整个（即第0个sub_match）匹配串之前的目录序列
suffix()            // 返回整个（即第0个sub_match）匹配串之后的目录序列
length(i)           // 返回第i个sub_match的长度
position(i)         // 返回第i个sub_match在目标序列中的位置　
str(i)              // 返回第i个sub_match的字符串

Formatting
format
Format replacement string (public member function )

注: sub_match提供了length()，str(), compare()方法，一般不常用，因为用match_results就够了:)


4) regex_match函数（正则表达式完全匹配目标序列时返回true,否则返回false)
基本形式：
bool regex_match(s, r, f)       // s为目标序列，r为正则表式，f为匹配标识（有缺省参数）
bool regex_match(s, m, r, f)    // s为目标序列，r为正则表式，f为匹配标识（有缺省参数）, m为匹配结果（cmatch/smatch）
注：s可以为c-string（如const char*）, 或string，或一对iterator:first,second, 若s为c-string,　则m应为cmatch, 否则m应为smatch

示例代码：
if (std::regex_match ("subject", std::regex("(sub)(.*)") ))
    std::cout << "string literal matched\n";

const char cstr[] = "subject";
std::string s ("subject");
std::regex e ("(sub)(.*)");

if (std::regex_match (s,e))
    std::cout << "string object matched\n";

if ( std::regex_match ( s.begin(), s.end(), e ) )
    std::cout << "range matched\n";

std::cmatch cm;
std::regex_match (cstr,cm,e);
std::cout << "string literal with " << cm.size() << " matches\n";

std::smatch sm;
std::regex_match (s,sm,e);
std::cout << "string object with " << sm.size() << " matches\n";

std::regex_match ( s.cbegin(), s.cend(), sm, e);
std::cout << "range with " << sm.size() << " matches\n";

std::regex_match ( cstr, cm, e, std::regex_constants::match_default );

std::cout << "the matches were: ";
for (unsigned i=0; i<sm.size(); ++i) {
    std::cout << "[" << sm[i] << "] ";
}
输出结果：
string literal matched
string object matched
range matched
string literal with 3 matches
string object with 3 matches
range with 3 matches
the matches were: [subject] [sub] [ject]

5) regex_search函数（正则表达式匹配目标子序列时返回true,否则返回false)
基本形式：
bool regex_search(s, r, f)       // s为目标序列，r为正则表式，f为匹配标识（有缺省参数）
bool regex_search(s, m, r, f)    // s为目标序列，r为正则表式，f为匹配标识（有缺省参数）, m为匹配结果（cmatch/smatch）

示例代码：
std::string s ("this subject has a submarine as a subsequence");
std::smatch m;
std::regex e ("\\b(sub)([^ ]*)");   // matches words beginning by "sub"

std::cout << "Target sequence: " << s << std::endl;
std::cout << "Regular expression: /\\b(sub)([^ ]*)/" << std::endl;
std::cout << "The following matches and submatches were found:" << std::endl;

while (std::regex_search (s,m,e)) {
    for (auto x:m) std::cout << x << " ";       // 注：m为smatch类型，m[0]为匹配的整个串，m[n]表示匹配的第n(n=1,2,3...)个group， m[x](x=0,1,2,3)类型为ssub_match
    std::cout << std::endl;
    s = m.suffix().str();                       // 返回匹配后辍，继续搜索
}

输出结果：
Target sequence: this subject has a submarine as subsequence
Regular expression: /\b(sub)([^ ]*)/
The following matches and submatches were found:
subject sub ject
submarine sub marine
subsequence sub sequence


6) regex_replace函数（用于替换目标序列)
基本形式：
string regex_replace(s, regex, replace, f)              // s为目标序列，regex为正则表式，replace为替换串，f为匹配标识（有缺省参数）, 返回替换后的串
out regex_replace(out, first, last, regex, replace, f)  // out为OutputIterator（替换后的串写入)，first,last为目标序列，其它同上，返回OutputIterator

示例代码：
std::string s ("there is a subsequence in the string\n");
std::regex e ("\\b(sub)([^ ]*)");                                                           // 匹配以"sub"开头的单词
std::cout << std::regex_replace (s,e,"sub-$2");                                             // 返回string

std::string result;
std::regex_replace (std::back_inserter(result), s.begin(), s.end(), e, "$2");               // 结果写入OutputIterator
std::cout << result;

std::cout << std::regex_replace (s,e,"$1 and $2",std::regex_constants::format_no_copy);     // 使用flags，返回OutputIterator
std::cout << std::endl;

输出结果：
there is a sub-sequence in the string
there is a sequence in the string
sub and sequence


7) 两个iterator：regex_iterator和regex_token_iterator
a. regex_iterator: 用于迭代所有匹配的正则表达式
示例代码：
std::string s ("this subject has a submarine as a subsequence");
std::regex e ("\\b(sub)([^ ]*)");
std::regex_iterator<std::string::iterator> rit(s.begin(), s.end(), e);       // 表示遍历s中正则表达式e的begin迭代器
std::regex_iterator<std::string::iterator> rend;                             // 缺省构造表示end迭代器
for (; rit!=rend; ++rit) {
    std::cout << rit->str() << std::endl;
}
输出结果：
subject
submarine
subsequence

b. regex_token_iterator：可以迭代匹配的正则表达式(及子匹配)相关token
regex_token_iterator  it_end                        // 缺省构造表示end迭代器
regex_token_iterator  it(b, e, r, submatch, f)      // b, e目标串的一对迭代器，r为正则表达式，submatch为子匹配索引, -1表示不匹配的部分（正则表达式作为分隔符）　
regex_token_iterator  it(b, e, r, submatchs, f)　　　　　// 同上，submatchs指定多个子匹配索引，submatch可以为int[N], initializer_list<int> 或vector<int>
示例代码：
std::string s ("this subject has a submarine as a subsequence");
std::regex e ("\\b(sub)([^ ]*)");
std::regex_token_iterator<std::string::iterator> rend;

std::cout << "entire matches:"; 
std::regex_token_iterator<std::string::iterator> a(s.begin(), s.end(), e);                  // 匹配整个正则表达式
while (a!=rend) std::cout << " [" << *a++ << "]";
std::cout << std::endl;

std::cout << "2nd submatches:";
std::regex_token_iterator<std::string::iterator> b ( s.begin(), s.end(), e, 2 );            // 第２个子匹配
while (b!=rend) std::cout << " [" << *b++ << "]";　
std::cout << std::endl;

std::cout << "1st and 2nd submatches:";
int submatches[] = { 1, 2 };
std::regex_token_iterator<std::string::iterator> c ( s.begin(), s.end(), e, submatches );   // 第１，２个子匹配
while (c!=rend) std::cout << " [" << *c++ << "]";
std::cout << std::endl;

std::cout << "matches as splitters:";
std::regex_token_iterator<std::string::iterator> d ( s.begin(), s.end(), e, -1 );           // -1表示以整个正则表达式为分隔符
while (d!=rend) std::cout << " [" << *d++ << "]";
输出结果:
entire amtches: [subject] [submarine] [subsequence]
2nd submatches: [ject] [marine] [sequence]
1st and 2nd submatches: [sub] [ject] [sub] [marine] [sub] [sequence]
matches as splitters: [this ] [ has a ] [ as a ]


5. 基于range的for循环
语法如下：
for(type-speciﬁer-seq simple-declarator : expression ) statement
语法上等价于：
{
    typedef decltype(expression) C;
    auto&& rng(expression);
    for (auto begin(std::For<C>::begin(rng)), end(std::For<C>::end(rng)); begin != end; ++ begin) {
        type-speciﬁer-seq simple-declarator(∗begin);
        statement
    }
}
C++ Primer上说：
for(auto& r: v) {
    ...
}
相当于：
for(auto begin = v.begin(), end = v.end(); begin != end; ++begin) {
    auto& r = (*begin);
    ...
}


6. std::function (<functional>)
std::function可封装任何可调用的对象（如函数, 函数指针, 定义了operator()的类, lambda表达式...），只要调用对象可拷贝即可。
注：std::function的类型只依赖调用签名，而不依赖于可调用对象的类型，这是一个相当好的特性。

template <class Ret, class... Args>     // Ret为返回值类型
class function<Ret(Args...)>;　　　        // Args为参数类型

例子：
int divid(int a, int b) { return a/b; }

std::function<int(int,int)> fn[] = {
    std::plus<int>(),
    std::minus<int>(),
    std::multiplies<int>(),
    divid
};

7. unordered_map/set/multimap/mulitset
由于旧的C++标准库中没有hash table, 不同的实现提供不同的hash table（hash table也命名成hash_map）
C++11实现了一个标准的hash table，为了不引起命令冲突，重新命为unordered_map
旧标准：hash_map, hash_multimap, hash_set, has_multiset
C++11：unordered_map, unordered_multimap, unordered_set, unordered_multiset

8. std::unique_ptr
std::unique_ptr（不同于boost::scoped_ptr）可指定用户deleter。unique：所有权唯一(即独占), 只能rvalue拷贝构造或赋值。

template <class T, class D = default_delete<T>> class unique_ptr;       // defalut_delete就是全局的delete 
template <class T, class D>  class unique_ptr<T[],D>;                   // 针对Array的特化版本

相关操作：
operator=           // 只能用rvalue引用或nullptr赋值
get()               // 返回T*
get_deleter()       // 返回deleter 
operator bool()     // 判断指针是否为空
release()           // 释放所有权，返回T*
reset()             // 重新设置（原有的指针会被delete)
swap()              // 交换所有权

operator*           // 解引用操作
operator->　　        // 指针操作　
operator[]　　        // 数组操作

例子（用户提供lambda　deleter）：
unique_ptr<int, void(*)(int*)> p(new int(100), [](int* p){　delete p; });


9. 除法舍入规则
如果两个运算对象符号相同，则商为正，否则商为负，C++11规定商一律向零取整（早期C++版本允许结果为负的商向上或向下取整）
根据取余运算的定义(m/n)*n + m%n应该等于m(如果n不为0), 隐含的意思是如果m%n的符号与m相同
例子：
21/6 == 3       21 % 6  == 3    
21/-6 == -3     21 % -6 == -3   
-21/6 == -3     -21 % 6 == -3











