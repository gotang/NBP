1. 从文件读取字符串
char* gets(char * str );                                    // 从标准输入读，读到换行或文件结束时返回，成功返回str（不包括换行符，包括'\0'字符），出错返回NULL
char* fgets(char * str, int num, FILE* stream);             // 同上，但可指定文件和读取的字符数，成功返回str（包括换行符，包括'\0'字符），出错返回NULL

istream& getline (istream&  is, string& str, char delim);   // 从指定流中读，读到分隔符或文件结束时返回，成功读取的字符调用push_back()加入到str中（不包括换行符，不包括'\0'字符）
istream& getline (istream& is, string& str);                // 同上，只是分隔字符为'\n'

istream& getline (istream&& is, string& str, char delim);   // 同上，C++11增加了右移参数类型版本
istream& getline (istream&& is, string& str);

例子：
ifstream ifs("input.txt");
string line;
while (std::getline(ifs, line, '\n')) {...}　                // line保存读取的行

2. 字符串连接
1）使用C函数
char* strcat(char* destination, const char* source);                    // 将source连接到destination后，返回destination（包括'\0'字符）
char* strncat(char * destination, const char* source, size_t num );     // 同上，指定连接source的前num个字符（'\0'字符会增加到destination，但不会计入num）

2）使用std::string::operator+=
string& operator+= (const string& str);	        // 连接string
string& operator+= (const char* s);             // 连接C风格字符串s
string& operator+= (char c);                    // 连接字符c
string& operator+= (initializer_list<char> il); // 连接initializer list (C++11增加）

3）使用std::operator+                            // 还有全局的operator+可用来连接string、C风格字符串、单个字符
string operator+ (const string& lhs, const string& rhs);
string operator+ (const string& lhs, const char*   rhs);
string operator+ (const char*   lhs, const string& rhs);
string operator+ (const string& lhs, char          rhs);
string operator+ (char          lhs, const string& rhs);
注：C++11中还有右移参数类型版本

3.分裂字符串
1）使用std::istream::operator>>抽取
＃include<sstream>
istringstream iss("one two \t three\t\nfour \r\n"); // 字符串的分隔符为空格、换行、TAB符的组合 
string sub; 
while (iss >> sub) cout << sub << endl;             // 抽取字符串，如果有字符串可以抽取
注：
a. 继承关系：ios_base <|-- ios <|-- istream <|-- istringstream
b. 还可以抽取如int,float,double等类型（可用于将string转化为int,float,double等）
istream& operator>> (int& val);
istream& operator>> (long int& val);
c.相应地std::ostream::operator<<可用于将int,float,double等类型转化为字符串，然后插入到流中
ostream& operator<< (int& val);
ostream& operator<< (long int& val);

2) 使用std::stringstream和std::getline，并指定分隔符
std::vector<std::string> split(const string& s, char delim) {
    vector<std::string> elems;
    stringstream ss(s);
    string item;
    while (getline(ss, item, delim)) 
        elems.push_back(item);
    return elems;
}

3) 使用C函数strtok分裂出token
char* strtok(char * str, const char* delimiters);
其中：
str 表示待分裂的串（NULL表示从上次token结束的地方开始）
delimiters  表示分隔字符的集合（集合中的任意字符是分隔字符）
strtok第一次调用时str不为NULL(以后每次调用时str可传NULL)，返回token的开始地址。
注：该函数的第一个参数没有const修饰，说明该函数会改变str的内容：将分隔字符替换成串结束符：\0.
示例代码：
char str[] ="- This, a sample string.";         // 注意strtok会改变str的内容（因此char* str="..." 写法有问题）
char* pch = strtok (str," ,.-");
while (pch != NULL) {
    printf ("%s\n",pch);
    pch = strtok (NULL, " ,.-");
}
输出结果：
This
a
sample
string


4. 字符串与整数之间的转换
字符串转整数
1）利用strtol和atoi（<stdlib.h>）                                // 返回：str无效返回0, 越界返回LONG_MAX或LONG_MIN，否则返回long值
long int strtol(const char* str, char** endptr, int base);      // *endprt返回str中数字后的位置（传入NULL忽略返回值）
                                                                // base表示进制（如：10/16/2表示str为10/16/2进制，0表示依str形式而定）

int atoi (const char * str);                                    // 返回：str无效返回0, 越界行为未定int值，否则返回（建议使用strtol）

注：
1) 类似strtol, 还有strtoul, strtoll, strtoull, strtod, strtof, strtold
2) 类似atoi, 还有atol, atoll, atof函数


2）利用stoi（<string>）
int stoi(const string&  str, size_t* idx = 0, int base = 10);   // 同上，内部调用strtol完成（C++11增加）
int stoi(const wstring& str, size_t* idx = 0, int base = 10);

3）使用stringstream（继承自istringstream和ostringstream）

stringstream ss;
int x;
ss << 100;          // 将100转化为字符串，并插入到ss
ss >> x;            // 从ss抽取字符串，并转化为int

注: 下例中从stringstream抽取的分隔符可以是换行，TAB, 空格及其组合
stringstream ss;
int a;
string b;
ss << 10;           // 将10转化为字符串"10"，并插入到ss（内容为“10”）
ss << 2;            // 将2转化为字符串"2"，并插入到ss（内容为“102”）
ss << " \t";        // 插入" \t"到ss（内容为“102 \t”）
ss << 3;            // 将3转化为字符串，并插入到ss（内容为“102 \t3”）
ss >> a;            // 从ss中抽取int字符串"102"，a为102
ss >> b;            // 从ss中抽取字符串"3"，b为"3"


整数转字符串
1）使用itoa
char* itoa(int value, char* str, int base);                     // 返回str, base表示进制（影响str）

2）使用sprintf格式化输出
int sprintf(char* str, const char* format, ... );               // 建议使用sprintf
int snprintf(char* s, size_t n, const char* format, ... );      // 更安全的版本，最多写入个n-1个字符到s，然后写入'\0'字符
注意：出错时返回负数， 否则返回格式化后的字符串长度（不管n是否容纳得下格式化后的字符串，显然，结尾的'\0'不计入字符串长度计算）

3) 使用stringstream（见上）

注：
1) boost库提供了lexical_cast模板函数，转换相当方便, 如：
B b = lexical_cast<A>(a);
A需满足: std::ostream << a (或std::wostream << a）
B需满足: std::istream >> b (或std::wistream >> b), 且B可拷贝和缺省构造

2) c++11中增加了各种重载的to_string()的将数字转换成字符串
string to_string (int val);
string to_string (long val);
string to_string (long long val);
string to_string (unsigned val);
string to_string (unsigned long val);
string to_string (unsigned long long val);
string to_string (float val);
string to_string (double val);
string to_string (long double val);

相应地，将字符串转换成数字使用sto*()函数
stoi(s, p, b)              　　 
stol(s, p, b)
stoul(s, p, b)
stoll(s, p, b)
stoull(s, p, b)
stod(s, p)
stof(s, p)
stold(s, p)
返回s字串数值，b表示转换所用的基数(缺省为10)，p是size_t保存第１个非数值下标（缺省为nullptr）




5. 字符串与时间之间的转换
1) linux下时间类型: 
time_t                  // 32位（如ARM）或64位（如x86_64）无符号整数
struct tm {
    int tm_sec;         /* seconds */
    int tm_min;         /* minutes */
    int tm_hour;        /* hours */
    int tm_mday;        /* day of the month */
    int tm_mon;         /* month */
    int tm_year;        /* year */
    int tm_wday;        /* day of the week */
    int tm_yday;        /* day in the year */
    int tm_isdst;       /* daylight saving time */
};

2) 时间到字符串的转换
char *asctime(const struct tm *tm);     // tm到字符串
char *ctime(const time_t *timep);       // time_t到字符串
size_t strftime(char *s, size_t max,    // tm到用户格式化串，s为输出, max为s的size
 　　　　　　　　　　　　　　　const char *format,     // format为输入 
                const struct tm *tm)    // tm为输入, 返回格式化串的长度，如果长度超过max返回0

3) 字符串到时间的转换 
char *strptime(const char *s,           // 输入字符串 
               const char *format,     　// 字符串格式　 
               struct tm *tm);          // 输出时间，返回s中未来处理的位置，或NULL(若失败)

　
4) 获取时间，tm与time_t的转换
time_t time(time_t *t);                 //　获取当前UTC秒数（1970-01-01 00:00:00）, 若t非空，则返回值也存在*t中

struct tm *gmtime(const time_t *timep); // time_t到tm转换
struct tm *localtime(const time_t *timep);

time_t mktime(struct tm *tm);           // tm到time_t转换







